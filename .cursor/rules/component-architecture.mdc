---
description: Component architecture patterns for Next.js 15 app directory structure
globs: src/components/**/*.tsx, src/app/**/*.tsx
alwaysApply: true
---

# Component Architecture

## **Directory Structure**
- **Features** → `src/components/features/{domain}/`
  - Group related components by business domain
  - Example: `features/agriculture/farm-core/`, `features/automation/integrations/`
- **Shared/UI** → `src/components/ui/`
  - Reusable UI components, design system elements
- **Layout** → `src/components/layout/`
  - Navigation, headers, footers, page layouts

## **Component Naming & Organization**
- **Feature components** → PascalCase with descriptive names
  ```typescript
  // ✅ DO: Clear, descriptive component names
  DeviceAssignmentWizard.tsx
  HomeAssistantConfigManager.tsx
  UnifiedFarmView/index.tsx

  // ❌ DON'T: Generic or unclear names
  Manager.tsx
  Component.tsx
  Utils.tsx
  ```

## **Service Integration Patterns**
- **Use dynamic imports** for better performance:
  ```typescript
  // ✅ DO: Dynamic service imports
  const handleDelete = async () => {
    const rackService = (await import('@/services/domain/farm/RackService')).RackService.getInstance();
    await rackService.delete(element.id);
  };

  // ✅ DO: Static imports for frequently used services
  const farmService = FarmService.getInstance();

  // ❌ DON'T: Mix old and new service patterns
  import { deleteRack } from '@/services/rackService';
  ```

## **Error Handling in Components**
- **Services handle errors automatically** - don't wrap service calls in try/catch
- **Use service results directly** - error handling is centralized:
  ```typescript
  // ✅ DO: Let services handle errors
  const handleSubmit = async (data: FormData) => {
    const farm = await farmService.create(data);
    toast.success('Farm created successfully');
    onSuccess(farm);
  };

  // ❌ DON'T: Redundant error handling
  const handleSubmit = async (data: FormData) => {
    try {
      const farm = await farmService.create(data);
      toast.success('Farm created successfully');
    } catch (error) {
      toast.error('Failed to create farm');
    }
  };
  ```

## **State Management**
- **Server state** → Use service methods directly
- **Client state** → React useState/useReducer for local UI state
- **Real-time data** → WebSocket services with subscriptions
  ```typescript
  // ✅ DO: Use real-time services for live data
  useEffect(() => {
    const subscription = homeAssistantService.subscribeToStateChanges(
      deviceId,
      (state) => setDeviceState(state)
    );
    return () => subscription?.unsubscribe();
  }, [deviceId]);
  ```

## **Type Safety**
- **Import types explicitly** from service domain types
- **Use proper interfaces** for component props
- **Avoid any types** - prefer unknown or proper typing

## **Performance Patterns**
- **Lazy load heavy components** with dynamic imports
- **Memoize expensive computations** with useMemo/useCallback
- **Optimize re-renders** with proper dependency arrays
