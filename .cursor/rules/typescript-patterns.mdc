---
description: TypeScript patterns for service architecture and domain modeling
globs: src/**/*.ts, src/**/*.tsx
alwaysApply: true
---

# TypeScript Patterns

## **Interface Design**
- **BaseEntity interface** → All domain entities extend this
- **Domain-specific types** → Organize by domain in `types/{domain}/`
- **Service interfaces** → Define contracts for service classes
  ```typescript
  // ✅ DO: Proper interface inheritance
  export interface Farm extends BaseEntity {
    name: string;
    location?: string;
    user_id: string;
  }

  // ✅ DO: Domain-specific organization
  // types/farm/layout.ts
  export interface Row extends BaseEntity { /* */ }
  export interface Rack extends BaseEntity { /* */ }
  ```

## **Generic Constraints**
- **Service generics** → Use proper constraints for type safety
- **Base class generics** → Ensure entities extend BaseEntity
  ```typescript
  // ✅ DO: Proper generic constraints
  export abstract class BaseCRUDService<T extends BaseEntity> {
    abstract readonly tableName: string;
    
    async getById(id: string): Promise<T | null> {
      // Type-safe implementation
    }
  }

  // ❌ DON'T: Unconstrained generics
  export abstract class BaseCRUDService<T> {
    // Less type safety
  }
  ```

## **Type Guards & Validation**
- **Runtime validation** → Use type guards for API responses
- **Service validation** → Built into base classes
- **Type narrowing** → Use proper type predicates
  ```typescript
  // ✅ DO: Type guards for API responses
  function isFarm(obj: any): obj is Farm {
    return obj && typeof obj.name === 'string' && typeof obj.user_id === 'string';
  }

  // ✅ DO: Service validation (built-in)
  this.validateRequired(data.name, 'name');
  this.validateId(data.user_id, 'user_id');
  ```

## **Utility Types**
- **Service return types** → Use consistent patterns
- **Create/Update types** → Omit system fields appropriately
  ```typescript
  // ✅ DO: Consistent service types
  type CreateFarmData = Omit<Farm, 'id' | 'created_at' | 'updated_at'>;
  type UpdateFarmData = Partial<CreateFarmData>;

  // ✅ DO: Service method signatures
  async create(data: CreateFarmData): Promise<Farm>;
  async update(id: string, data: UpdateFarmData): Promise<Farm>;
  ```

## **Enum vs Union Types**
- **Use string unions** for domain values that may change
- **Use const assertions** for static configuration
- **Avoid numeric enums** unless specifically needed
  ```typescript
  // ✅ DO: String unions for domain values
  type TaskStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

  // ✅ DO: Const assertions for static config
  const API_ENDPOINTS = {
    FARMS: '/api/farms',
    DEVICES: '/api/devices'
  } as const;
  ```

## **Error Handling Types**
- **Service errors** → Use consistent error types
- **Type-safe error responses** → Define error interfaces
- **Never use any** → Prefer unknown for uncertain types
  ```typescript
  // ✅ DO: Service error handling (built-in)
  // Services automatically handle and type errors

  // ✅ DO: Unknown over any
  function processApiResponse(response: unknown) {
    if (isFarm(response)) {
      // Type narrowed to Farm
    }
     }
   ```
