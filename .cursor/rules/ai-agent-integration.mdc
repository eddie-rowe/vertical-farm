# AI Agent Integration Patterns

## Core Principles

### 1. AI-Readable Code Structure
- **Clear Intent**: Code that clearly expresses business logic and purpose
- **Consistent Patterns**: Predictable structure for AI agents to understand and modify
- **Self-Documenting**: Minimal comments needed, code speaks for itself
- **Modular Design**: Easy for AI to identify and modify specific functionality

### 2. Multi-Agent Workflow Compatibility
- **Atomic Changes**: Small, focused modifications that don't break other agents' work
- **Clear Boundaries**: Well-defined interfaces between different code sections
- **Version Resilience**: Code that remains functional during iterative AI modifications
- **Rollback Safety**: Easy to revert changes without breaking dependencies

## Service Architecture for AI Agents

### AI-Friendly Service Patterns
```typescript
// ✅ DO: Clear, descriptive service methods
export class FarmManagementService extends BaseCRUDService<Farm> {
  private static instance: FarmManagementService

  static getInstance(): FarmManagementService {
    if (!FarmManagementService.instance) {
      FarmManagementService.instance = new FarmManagementService()
    }
    return FarmManagementService.instance
  }

  /**
   * Creates a new farm with initial configuration
   * AI Agent Context: This method handles complete farm setup including devices
   */
  async createFarmWithInitialSetup(farmData: CreateFarmRequest): Promise<Farm> {
    this.validateFarmData(farmData)
    
    const farm = await this.createFarm(farmData.basicInfo)
    await this.setupInitialDevices(farm.id, farmData.deviceConfig)
    await this.configureDefaultSensors(farm.id, farmData.sensorTypes)
    
    return this.getFarmWithFullDetails(farm.id)
  }

  /**
   * Updates farm irrigation schedule
   * AI Agent Context: Only modifies irrigation, safe to call independently
   */
  async updateIrrigationSchedule(
    farmId: string, 
    schedule: IrrigationSchedule
  ): Promise<void> {
    await this.validateFarmAccess(farmId)
    await this.validateScheduleConflicts(farmId, schedule)
    
    const deviceService = DeviceControlService.getInstance()
    await deviceService.updateIrrigationDevices(farmId, schedule)
    
    // Notify other systems of the change
    await this.notifyScheduleUpdate(farmId, schedule)
  }

  /**
   * Retrieves comprehensive farm analytics
   * AI Agent Context: Read-only operation, safe for concurrent access
   */
  async getFarmAnalyticsReport(
    farmId: string,
    timeRange: TimeRange
  ): Promise<FarmAnalyticsReport> {
    const analyticsService = FarmAnalyticsService.getInstance()
    
    const [
      efficiencyMetrics,
      sensorTrends,
      devicePerformance,
      costAnalysis
    ] = await Promise.all([
      analyticsService.getEfficiencyMetrics(farmId, timeRange),
      analyticsService.getSensorTrends(farmId, timeRange),
      analyticsService.getDevicePerformance(farmId, timeRange),
      analyticsService.getCostAnalysis(farmId, timeRange)
    ])
    
    return {
      farmId,
      timeRange,
      efficiencyMetrics,
      sensorTrends,
      devicePerformance,
      costAnalysis,
      generatedAt: new Date().toISOString()
    }
  }
}
```

### AI Agent Safe Modification Patterns
```typescript
// ✅ DO: Extensible enums for AI to add new types
export const DeviceType = {
  IRRIGATION_PUMP: 'IRRIGATION_PUMP',
  LED_LIGHT: 'LED_LIGHT',
  TEMPERATURE_SENSOR: 'TEMPERATURE_SENSOR',
  HUMIDITY_SENSOR: 'HUMIDITY_SENSOR',
  PH_SENSOR: 'PH_SENSOR',
  // AI agents can safely add new types here
} as const

export type DeviceType = typeof DeviceType[keyof typeof DeviceType]

// ✅ DO: Configuration objects for AI to modify
export const FarmConfiguration = {
  irrigation: {
    defaultSchedule: {
      morningStart: '06:00',
      morningDuration: 30, // minutes
      eveningStart: '18:00',
      eveningDuration: 25
    },
    moistureThresholds: {
      low: 30, // percentage
      optimal: 65,
      high: 85
    }
  },
  
  lighting: {
    defaultSchedule: {
      onTime: '06:00',
      offTime: '22:00'
    },
    intensityLevels: {
      seedling: 25, // percentage
      vegetative: 75,
      flowering: 100
    }
  },
  
  // AI agents can safely modify these values
  alerts: {
    temperatureThresholds: {
      min: 18, // Celsius
      max: 28
    },
    humidityThresholds: {
      min: 40, // percentage
      max: 80
    }
  }
} as const
```

## Component Patterns for AI Modification

### AI-Friendly Component Structure
```typescript
// ✅ DO: Component with clear, modifiable sections
export function FarmDashboard({ farmId }: { farmId: string }) {
  const farmData = useFarmData(farmId)
  const sensorData = useSensorData(farmId)
  const deviceStatus = useDeviceStatus(farmId)
  
  // AI Agent Section: Header Configuration
  const headerConfig = {
    showWeather: true,
    showEfficiency: true,
    showAlerts: true,
    refreshInterval: 30000 // ms
  }
  
  // AI Agent Section: Grid Layout Configuration
  const gridLayout = {
    columns: 3,
    rows: 2,
    gap: 6,
    components: [
      { type: 'SensorChart', position: { col: 1, row: 1 } },
      { type: 'DeviceGrid', position: { col: 2, row: 1 } },
      { type: 'WeatherWidget', position: { col: 3, row: 1 } },
      { type: 'AlertsPanel', position: { col: 1, row: 2, colspan: 2 } },
      { type: 'EfficiencyMetrics', position: { col: 3, row: 2 } }
    ]
  }
  
  // AI Agent Section: Component Props Configuration
  const componentProps = {
    sensorChart: {
      timeRange: '24h',
      sensorTypes: ['temperature', 'humidity', 'ph'],
      showPredictions: true
    },
    deviceGrid: {
      showStatus: true,
      allowControl: true,
      groupBy: 'type'
    },
    weatherWidget: {
      showForecast: true,
      forecastDays: 3,
      showUV: true
    }
  }
  
  return (
    <div className="farm-dashboard">
      <FarmHeader 
        farm={farmData} 
        config={headerConfig}
      />
      
      <DynamicGrid 
        layout={gridLayout}
        components={gridLayout.components}
        data={{
          sensorData,
          deviceStatus,
          farmData
        }}
        componentProps={componentProps}
      />
    </div>
  )
}

// ✅ DO: Reusable component with clear configuration
export function DeviceControlPanel({ 
  deviceId, 
  config = DEFAULT_DEVICE_CONTROL_CONFIG 
}: DeviceControlPanelProps) {
  
  // AI Agent Section: Control Configuration
  const controlConfig = {
    ...DEFAULT_DEVICE_CONTROL_CONFIG,
    ...config,
    // AI agents can override specific controls
    enabledControls: config.enabledControls || [
      'power',
      'intensity', 
      'schedule',
      'manual_override'
    ],
    confirmationRequired: config.confirmationRequired || [
      'power',
      'manual_override'
    ]
  }
  
  return (
    <div className="device-control-panel">
      {controlConfig.enabledControls.map(controlType => (
        <DeviceControl
          key={controlType}
          type={controlType}
          deviceId={deviceId}
          requireConfirmation={controlConfig.confirmationRequired.includes(controlType)}
        />
      ))}
    </div>
  )
}
```

### Configuration-Driven Development
```typescript
// ✅ DO: External configuration files for AI to modify
// config/farm-display.ts
export const FarmDisplayConfig = {
  dashboard: {
    refreshIntervals: {
      sensors: 5000,    // 5 seconds
      devices: 10000,   // 10 seconds
      weather: 300000,  // 5 minutes
      analytics: 600000 // 10 minutes
    },
    
    chartTypes: {
      temperature: 'line',
      humidity: 'area',
      ph: 'line',
      efficiency: 'bar'
    },
    
    alertLevels: {
      info: { color: 'blue', duration: 5000 },
      warning: { color: 'orange', duration: 8000 },
      error: { color: 'red', duration: 0 }, // persistent
      critical: { color: 'red', duration: 0, sound: true }
    }
  },
  
  deviceControl: {
    batchOperations: true,
    confirmationTimeouts: {
      low_risk: 3000,
      medium_risk: 5000,
      high_risk: 10000
    },
    
    automaticRetry: {
      enabled: true,
      maxAttempts: 3,
      backoffMultiplier: 1.5
    }
  }
}

// Usage in components
export function ConfigurableFarmChart({ farmId, sensorType }: ChartProps) {
  const config = FarmDisplayConfig.dashboard
  const chartType = config.chartTypes[sensorType] || 'line'
  const refreshInterval = config.refreshIntervals.sensors
  
  return (
    <Chart
      type={chartType}
      refreshInterval={refreshInterval}
      data={useSensorData(farmId, sensorType, refreshInterval)}
    />
  )
}
```

## AI Agent Development Workflows

### Task-Oriented Code Organization
```typescript
// ✅ DO: Clear task boundaries for AI agents
// tasks/irrigation-management.ts
export class IrrigationManagementTask {
  /**
   * TASK: Update irrigation schedule for a farm
   * AI SAFETY: This task only modifies irrigation, won't affect other systems
   * DEPENDENCIES: FarmService, DeviceControlService
   * ROLLBACK: Can be safely reverted without affecting sensors or lighting
   */
  static async updateIrrigationSchedule(
    farmId: string,
    newSchedule: IrrigationSchedule
  ): Promise<TaskResult> {
    const farmService = FarmManagementService.getInstance()
    
    try {
      await farmService.updateIrrigationSchedule(farmId, newSchedule)
      
      return {
        success: true,
        taskId: 'irrigation-schedule-update',
        farmId,
        changes: ['irrigation_schedule'],
        rollbackData: await farmService.getIrrigationSchedule(farmId)
      }
    } catch (error) {
      return {
        success: false,
        taskId: 'irrigation-schedule-update',
        error: error.message,
        rollbackRequired: false // No changes made
      }
    }
  }
}

// tasks/sensor-configuration.ts
export class SensorConfigurationTask {
  /**
   * TASK: Add new sensor types to farm monitoring
   * AI SAFETY: Only adds new sensors, doesn't modify existing ones
   * DEPENDENCIES: SensorService, FarmMonitoringService
   * ROLLBACK: Can remove added sensors without affecting existing monitoring
   */
  static async addSensorTypes(
    farmId: string,
    sensorTypes: SensorType[]
  ): Promise<TaskResult> {
    const monitoringService = FarmMonitoringService.getInstance()
    const addedSensors: string[] = []
    
    try {
      for (const sensorType of sensorTypes) {
        const sensorId = await monitoringService.addSensorType(farmId, sensorType)
        addedSensors.push(sensorId)
      }
      
      return {
        success: true,
        taskId: 'add-sensor-types',
        farmId,
        changes: ['sensor_configuration'],
        rollbackData: { addedSensors }
      }
    } catch (error) {
      // Cleanup any sensors that were added before the error
      await this.cleanupAddedSensors(farmId, addedSensors)
      
      return {
        success: false,
        taskId: 'add-sensor-types',
        error: error.message,
        rollbackRequired: true,
        rollbackData: { addedSensors }
      }
    }
  }
}
```

### AI Agent Communication Patterns
```typescript
// ✅ DO: Clear interfaces for agent communication
export interface AgentTaskResult {
  agentId: string
  taskId: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed'
  farmId?: string
  changes: string[]
  dependencies: string[]
  conflicts?: string[]
  rollbackData?: any
  timestamp: string
}

export interface AgentCoordination {
  canExecute(taskId: string, dependencies: string[]): Promise<boolean>
  reportProgress(result: AgentTaskResult): Promise<void>
  checkConflicts(changes: string[]): Promise<string[]>
  requestRollback(taskId: string): Promise<boolean>
}

// AI Agent communication service
export class AgentCoordinationService implements AgentCoordination {
  private static instance: AgentCoordinationService
  private activeTasks: Map<string, AgentTaskResult> = new Map()
  
  static getInstance(): AgentCoordinationService {
    if (!AgentCoordinationService.instance) {
      AgentCoordinationService.instance = new AgentCoordinationService()
    }
    return AgentCoordinationService.instance
  }
  
  async canExecute(taskId: string, dependencies: string[]): Promise<boolean> {
    // Check if any dependencies are currently being modified
    for (const [activeTaskId, task] of this.activeTasks) {
      if (task.status === 'in_progress') {
        const hasConflict = task.changes.some(change => 
          dependencies.includes(change)
        )
        
        if (hasConflict) {
          console.log(`Task ${taskId} blocked by ${activeTaskId}`)
          return false
        }
      }
    }
    
    return true
  }
  
  async reportProgress(result: AgentTaskResult): Promise<void> {
    this.activeTasks.set(result.taskId, result)
    
    // Clean up completed tasks after 5 minutes
    if (result.status === 'completed' || result.status === 'failed') {
      setTimeout(() => {
        this.activeTasks.delete(result.taskId)
      }, 5 * 60 * 1000)
    }
  }
  
  async checkConflicts(changes: string[]): Promise<string[]> {
    const conflicts: string[] = []
    
    for (const [taskId, task] of this.activeTasks) {
      if (task.status === 'in_progress') {
        const conflictingChanges = task.changes.filter(change =>
          changes.includes(change)
        )
        
        if (conflictingChanges.length > 0) {
          conflicts.push(taskId)
        }
      }
    }
    
    return conflicts
  }
}
```

## Documentation Patterns for AI

### Self-Documenting Code Structure
```typescript
// ✅ DO: Code that explains its purpose and constraints
export class DeviceAutomationRule {
  /**
   * Automation rule for device control based on sensor readings
   * 
   * CONSTRAINT: Only one rule per device-sensor combination
   * SAFETY: Rules are evaluated in priority order (higher numbers first)
   * AI_MODIFICATION: Safe to add new rules, modify thresholds
   * AI_CAUTION: Changing evaluation logic affects all existing rules
   */
  constructor(
    public readonly id: string,
    public readonly deviceId: string,
    public readonly sensorType: SensorType,
    public readonly condition: AutomationCondition,
    public readonly action: DeviceAction,
    public readonly priority: number = 100
  ) {}
  
  /**
   * Evaluates if this rule should trigger based on sensor reading
   * 
   * @param reading - Current sensor reading
   * @returns true if rule conditions are met
   * 
   * AI_SAFE: Pure function, no side effects
   * AI_TESTABLE: Easy to unit test with different sensor values
   */
  shouldTrigger(reading: SensorReading): boolean {
    switch (this.condition.operator) {
      case 'GREATER_THAN':
        return reading.value > this.condition.threshold
      
      case 'LESS_THAN':
        return reading.value < this.condition.threshold
      
      case 'EQUALS':
        return Math.abs(reading.value - this.condition.threshold) < 0.01
      
      case 'BETWEEN':
        return reading.value >= this.condition.min && 
               reading.value <= this.condition.max
      
      default:
        return false
    }
  }
  
  /**
   * Creates device action from this rule
   * 
   * AI_MODIFICATION: Safe to add new action types
   * AI_TESTING: Mock DeviceControlService for testing
   */
  async executeAction(): Promise<void> {
    const deviceService = DeviceControlService.getInstance()
    
    switch (this.action.type) {
      case 'SET_POWER':
        await deviceService.setPower(this.deviceId, this.action.value)
        break
        
      case 'SET_INTENSITY':
        await deviceService.setIntensity(this.deviceId, this.action.value)
        break
        
      case 'ACTIVATE_SCHEDULE':
        await deviceService.activateSchedule(this.deviceId, this.action.scheduleId)
        break
        
      // AI agents can safely add new action types here
      default:
        throw new Error(`Unknown action type: ${this.action.type}`)
    }
  }
}
```

### AI-Friendly Type Definitions
```typescript
// ✅ DO: Comprehensive types that guide AI understanding
export interface FarmEntityRelationships {
  /**
   * Complete type definition for farm entity relationships
   * AI_USAGE: Use this to understand the farm data structure
   * AI_SAFETY: All relationships are typed and validated
   */
  
  farm: {
    id: string
    name: string
    location: GeoLocation
    size: FarmSize
    type: FarmType
    
    // Related entities (AI can safely navigate these relationships)
    rows: Row[]
    devices: Device[]
    sensors: Sensor[]
    automationRules: AutomationRule[]
    users: FarmUser[]
  }
  
  row: {
    id: string
    farmId: string // Foreign key to farm
    position: number
    
    // Child entities
    racks: Rack[]
  }
  
  rack: {
    id: string
    rowId: string // Foreign key to row
    position: number
    
    // Child entities
    shelves: Shelf[]
    devices: Device[] // Devices specific to this rack
  }
  
  shelf: {
    id: string
    rackId: string // Foreign key to rack
    position: number
    
    // Associated entities
    plants: Plant[]
    sensors: Sensor[] // Sensors specific to this shelf
  }
}

// ✅ DO: Validation schemas that AI can understand and extend
export const FarmValidationRules = {
  farm: {
    name: {
      required: true,
      minLength: 2,
      maxLength: 100,
      pattern: /^[a-zA-Z0-9\s\-_]+$/
    },
    
    size: {
      required: true,
      min: 1, // square meters
      max: 10000
    }
    
    // AI agents can add new validation rules here
  },
  
  device: {
    name: {
      required: true,
      minLength: 3,
      maxLength: 50
    },
    
    type: {
      required: true,
      enum: Object.values(DeviceType)
    },
    
    powerRating: {
      required: true,
      min: 0,
      max: 5000 // watts
    }
  }
  
  // AI can extend validation rules for new entity types
} as const
```

## Testing Patterns for AI Development

### AI-Friendly Test Structure
```typescript
// ✅ DO: Clear, isolated tests that AI can understand and extend
describe('IrrigationManagementTask', () => {
  // AI_CONTEXT: Testing irrigation scheduling functionality
  // AI_SAFETY: Tests are isolated and don't affect other systems
  
  describe('updateIrrigationSchedule', () => {
    beforeEach(() => {
      // Clear setup for each test
      vi.clearAllMocks()
      
      // Mock external dependencies
      vi.mocked(FarmManagementService.getInstance).mockReturnValue({
        updateIrrigationSchedule: vi.fn(),
        getIrrigationSchedule: vi.fn()
      } as any)
    })
    
    it('should successfully update irrigation schedule', async () => {
      // AI_PATTERN: Arrange-Act-Assert structure
      
      // Arrange
      const farmId = 'test-farm-1'
      const newSchedule: IrrigationSchedule = {
        morningStart: '07:00',
        morningDuration: 25,
        eveningStart: '19:00',
        eveningDuration: 20
      }
      
      // Act
      const result = await IrrigationManagementTask.updateIrrigationSchedule(
        farmId, 
        newSchedule
      )
      
      // Assert
      expect(result.success).toBe(true)
      expect(result.taskId).toBe('irrigation-schedule-update')
      expect(result.farmId).toBe(farmId)
      expect(result.changes).toContain('irrigation_schedule')
    })
    
    it('should handle validation errors gracefully', async () => {
      // AI_SAFETY: Error handling test ensures robustness
      
      const farmId = 'test-farm-1'
      const invalidSchedule = {} as IrrigationSchedule
      
      vi.mocked(FarmManagementService.getInstance().updateIrrigationSchedule)
        .mockRejectedValue(new Error('Invalid schedule'))
      
      const result = await IrrigationManagementTask.updateIrrigationSchedule(
        farmId,
        invalidSchedule
      )
      
      expect(result.success).toBe(false)
      expect(result.error).toBe('Invalid schedule')
      expect(result.rollbackRequired).toBe(false)
    })
    
    // AI agents can add more test cases here following the same pattern
  })
})

// ✅ DO: Integration tests for AI to understand system behavior
describe('Farm System Integration', () => {
  // AI_CONTEXT: End-to-end behavior of farm management
  // AI_UNDERSTANDING: How different services work together
  
  it('should coordinate irrigation and sensor monitoring', async () => {
    // AI_PATTERN: Multi-service integration test
    
    const farmId = 'integration-test-farm'
    
    // Setup farm with sensors
    const farmService = FarmManagementService.getInstance()
    const monitoringService = FarmMonitoringService.getInstance()
    
    const farm = await farmService.createFarmWithInitialSetup({
      basicInfo: { name: 'Test Farm', location: 'Test Location' },
      deviceConfig: { irrigationPumps: 2, ledLights: 4 },
      sensorTypes: ['moisture', 'temperature']
    })
    
    // Update irrigation schedule
    await farmService.updateIrrigationSchedule(farmId, {
      morningStart: '06:00',
      morningDuration: 30,
      eveningStart: '18:00',
      eveningDuration: 25
    })
    
    // Verify sensors are monitoring the right parameters
    const activeMonitoring = await monitoringService.getActiveMonitoring(farmId)
    
    expect(activeMonitoring.sensorTypes).toContain('moisture')
    expect(activeMonitoring.irrigationSchedule).toBeDefined()
    expect(activeMonitoring.alertThresholds.moisture).toBeDefined()
  })
})
```

This AI agent integration approach ensures that your codebase remains maintainable and extensible while being optimized for AI-driven development workflows.
description:
globs:
alwaysApply: false
---
