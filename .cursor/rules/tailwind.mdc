
# Tailwind CSS Best Practices

## **Design System Architecture**
- **Button Components** → Use standardized [Button](mdc:vertical-farm/frontend/src/components/ui/button.tsx) component with CVA variants
- **Farm Controls** → Use `FarmControlButton` (wraps main Button) or Button with farm variants
- **Touch Targets** → All interactive elements minimum 44px (use `control` or `control-icon` sizes)
- **Utility Classes** → Use `farm-control-base` for farm-specific styling without size conflicts

## **Button Standardization (Updated)**
```typescript
// ✅ DO: Use standardized Button component with variants
<Button variant="primary" size="control">Farm Action</Button>
<Button variant="destructive" size="control-icon"><Icon /></Button>

// ✅ DO: Use FarmControlButton for farm-specific styling  
<FarmControlButton variant="maintenance" size="default">Maintenance</FarmControlButton>

// ✅ DO: Farm variants for specialized use cases
<Button variant="growing" size="control">Growing Cycle</Button>
<Button variant="offline" size="control">Offline Device</Button>

// ❌ DON'T: Hardcode button styles or mix systems
<button className="bg-red-500 text-white min-h-[44px]">Wrong</button>
<FarmControlButton className="min-h-[44px]">Redundant</FarmControlButton>
```

## **Farm Control Utilities**
```css
/* ✅ DO: Use farm-control-base for size-agnostic farm styling */
@utility farm-control-base {
  @apply glass card-shadow;
  /* Provides farm visual identity without sizing conflicts */
}

/* ✅ DO: Use Button size variants for responsive sizing */
.control-size { height: 2.75rem; } /* 44px touch target */
.control-icon-size { width: 2.75rem; height: 2.75rem; } /* 44px square */

/* ❌ DON'T: Override Button sizing with farm-control-btn */
/* Legacy farm-control-btn has fixed 2.5rem - use only for backward compatibility */
```

## **Touch Target Requirements**
- **Minimum Size**: 44px × 44px for all interactive elements
- **Button Sizes**: Use `control` (44px height) or `control-icon` (44px square)
- **Text Input Height**: Use `h-11` (44px) for form controls
- **Legacy Override**: Remove `min-h-[44px]` - no longer needed with proper sizing

## **Color System & Variants**
```typescript
// ✅ DO: Use semantic Button variants instead of hardcoded colors
<Button variant="destructive">Delete</Button>        // Instead of bg-red-500
<Button variant="primary">Primary Action</Button>    // Instead of bg-blue-500
<Button variant="outline">Secondary</Button>         // Instead of custom borders

// ✅ DO: Farm-specific variants for domain context
<Button variant="maintenance">Maintenance Mode</Button>
<Button variant="growing">Growing Active</Button>
<Button variant="offline">Device Offline</Button>

// ❌ DON'T: Hardcode colors that bypass design system
<Button className="bg-red-500 text-white border-red-500">Wrong</Button>
```

## **Component Integration Patterns**
```typescript
// ✅ DO: FarmControlButton for farm contexts (uses Button internally)
import { FarmControlButton } from '@/components/ui/farm-control-button';
<FarmControlButton variant="primary" size="default">Farm Action</FarmControlButton>

// ✅ DO: Button component for general use cases
import { Button } from '@/components/ui/button';
<Button variant="destructive" size="control">Delete Item</Button>

// ✅ DO: Dynamic imports for performance
const handleDelete = async () => {
  const service = (await import('@/services/domain/farm/RackService')).RackService.getInstance();
  await service.delete(id);
};

// ❌ DON'T: Mix old and new button patterns
import { deleteRack } from '@/services/rackService'; // Legacy pattern
```

## **Responsive Design**
- **Mobile First**: Default sizes work on mobile (44px touch targets)
- **Desktop Enhancement**: Use size variants for larger screens if needed
- **Consistent Spacing**: Use design system spacing tokens (`space-*`)
- **Flexible Layouts**: Use CSS Grid and Flexbox with responsive classes

## **Performance Optimization**
- **Class Merging**: Use `cn()` utility for conditional classes
- **Variant Groups**: Group related styles with CVA (Class Variance Authority)
- **Purge Unused**: Tailwind automatically removes unused classes
- **Component Variants**: Use CVA for systematic styling variations

## **Accessibility Patterns**
- **Focus Indicators**: All buttons have proper focus-visible styles
- **Screen Readers**: Use proper ARIA labels and descriptions
- **Color Contrast**: Design system ensures WCAG compliance
- **Touch Targets**: 44px minimum for mobile accessibility

## **Migration Guide**
When updating existing buttons:
1. **Replace hardcoded styles** with Button variants
2. **Remove min-h-[44px] overrides** - use proper size variants instead  
3. **Update FarmControlButton usage** - remove redundant className overrides
4. **Use semantic variants** - destructive for delete, primary for main actions
5. **Test touch targets** - ensure 44px minimum on mobile devices

## **Search & Filter Standardization**

### **Standardized Search Components**
```typescript
// ✅ DO: Use FarmSearchInput for consistent search functionality
import { FarmSearchInput } from '@/components/ui/farm-search-input';

<FarmSearchInput
  value={searchTerm}
  onSearchChange={setSearchTerm}
  searchContext="devices, farms, or alerts"  // Generates: "Search devices, farms, or alerts..."
  showClearButton={true}
  debounceMs={300}
/>

// ✅ DO: Use placeholder patterns consistently
searchContext="devices"           → "Search devices..."
searchContext="by name or type"   → "Search by name or type..."  
placeholder="Custom text..."      → "Custom text..." (override)

// ❌ DON'T: Manual search implementations
<FarmInput 
  icon={<FaSearch />} 
  placeholder="Search devices..." 
  onChange={handleManualSearch}
/>
```

### **Standardized Filter Components**
```typescript
// ✅ DO: Use FarmFilterChips for active filter display
import { FarmFilterChips, type FilterChip } from '@/components/ui/farm-filter-chips';

const activeFilters: FilterChip[] = [
  { id: 'status', label: 'Active', value: 'active', type: 'status' },
  { id: 'farm', label: 'Farm A', value: 'farm-a', type: 'farm' }
];

<FarmFilterChips
  filters={activeFilters}
  onRemoveFilter={handleRemoveFilter}
  onClearAll={handleClearAllFilters}
  showClearAll={true}
  label="Active Filters:"
/>

// ✅ DO: Use composite component for complex layouts
import { FarmSearchAndFilter } from '@/components/ui/farm-search-and-filter';

<FarmSearchAndFilter
  searchValue={searchTerm}
  onSearchChange={setSearchTerm}
  searchContext="devices"
  filters={filterDefinitions}
  activeFilters={activeFilterChips}
  onFilterChange={handleFilterChange}
  onRemoveFilter={handleRemoveFilter}
  orientation="horizontal"
/>

// ❌ DON'T: Inconsistent filter implementations
<Select placeholder="Filter by status...">  // Mixed pattern
  <option value="all">All Status</option>
</Select>
```

### **Search & Filter State Management**
```typescript
// ✅ DO: Use standardized hooks for state management
import { useFarmSearch, useFarmFilters } from '@/hooks';

// Search state with debouncing and filtering
const {
  searchTerm,
  setSearchTerm,
  clearSearch,
  filterItems: searchFilterItems,
  hasSearch
} = useFarmSearch<Device>({
  searchFields: ['name', 'type', 'location'],
  caseSensitive: false
});

// Filter state with chips management
const {
  filters,
  setFilter,
  removeFilter,
  clearAllFilters,
  getActiveFilterChips,
  filterItems: filterFilterItems,
  hasActiveFilters
} = useFarmFilters<Device>();

// ✅ DO: Combine search and filters
const filteredDevices = useMemo(() => {
  let result = devices;
  result = searchFilterItems(result);
  result = filterFilterItems(result);
  return result;
}, [devices, searchFilterItems, filterFilterItems]);

// ❌ DON'T: Manual state management without hooks
const [searchTerm, setSearchTerm] = useState('');
const [statusFilter, setStatusFilter] = useState('all');
const [farmFilter, setFarmFilter] = useState('all');
// ... manual filtering logic
```

### **Consistent Placeholder Text Patterns**
```typescript
// ✅ DO: Follow standardized placeholder patterns
"Search devices..."                     // Simple context
"Search farms, devices, or alerts..."   // Multiple contexts  
"Search by name, type, or location..."  // Search criteria
"Filter by status"                      // Filter labels
"All Devices"                          // Filter default options

// ❌ DON'T: Inconsistent patterns
"Search for devices..."                 // Inconsistent preposition
"Find farms..."                        // Different verb
"Device search..."                     // Reversed order
"All"                                  // Unclear default
```

### **Filter Option Patterns**
```typescript
// ✅ DO: Consistent filter option structure
const statusFilter = {
  id: 'status',
  label: 'Status',
  placeholder: 'Filter by status',
  options: [
    { value: 'all', label: 'All Devices' },      // Always lead with "All [Items]"
    { value: 'active', label: 'Active' },
    { value: 'inactive', label: 'Inactive' },
    { value: 'maintenance', label: 'Maintenance' }
  ],
  defaultValue: 'all'
};

// ❌ DON'T: Inconsistent option patterns
options: [
  { value: '', label: 'Any Status' },           // Mixed empty/all patterns
  { value: 'active', label: 'Active Devices' }, // Inconsistent label style
]
```

### **Migration Guide for Search & Filters**
1. **Replace manual search inputs** with `FarmSearchInput`
2. **Standardize placeholder text** using consistent patterns
3. **Convert filter chips** to use `FarmFilterChips` component
4. **Adopt standardized hooks** (`useFarmSearch`, `useFarmFilters`)
5. **Use composite components** for complex search+filter layouts
6. **Update filter option structure** to follow "All [Items]" pattern
7. **Remove manual debouncing** - built into `FarmSearchInput`

Follow [component-architecture.mdc](mdc:.cursor/rules/component-architecture.mdc) for component patterns and [import-organization.mdc](mdc:.cursor/rules/import-organization.mdc) for proper imports. 
- Keep styles organized
- Use proper documentation
- Implement proper testing
- Follow accessibility guidelines
- Use proper version control 