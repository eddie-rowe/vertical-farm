import { supabase } from '../supabaseClient';

// Define the type for Farm data based on your schema
// Adjust this based on your actual farms table structure in database-schema.md
export interface Farm {
  id?: string; // UUID, usually generated by Supabase, optional for creation
  name: string;
  location?: string | null;
  // manager_id is usually set server-side on creation, not directly by client for createFarm
  // manager_id?: string | null; 
  created_at?: string; // TIMESTAMPTZ
  updated_at?: string; // TIMESTAMPTZ
}

// Enum for PermissionLevel, matching backend
export enum PermissionLevel {
  VIEWER = 'viewer',
  EDITOR = 'editor',
  MANAGER = 'manager',
}

// Interface for UserPermission data, matching backend UserPermission model
export interface UserPermission {
  id: string; // UUID
  farm_id: string; // UUID
  user_id: string; // UUID
  permission: PermissionLevel;
  created_at: string; // TIMESTAMPTZ
  updated_at: string; // TIMESTAMPTZ
}

// Interface for creating a new permission
export interface UserPermissionCreatePayload {
  farm_id: string;
  user_id: string;
  permission: PermissionLevel;
}

// Interface for updating an existing permission
export interface UserPermissionUpdatePayload {
  permission: PermissionLevel;
}

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

/**
 * Helper function to get the authorization header.
 */
const getAuthHeader = async () => {
  const session = (await supabase.auth.getSession()).data.session;
  if (!session) {
    throw new Error('User not authenticated.');
  }
  return {
    'Authorization': `Bearer ${session.access_token}`,
    'Content-Type': 'application/json',
  };
};

/**
 * Fetches all farms.
 * Relies on RLS policies for security.
 */
export const getFarms = async (): Promise<Farm[]> => {
  const { data, error } = await supabase.from('farms').select('*');
  if (error) {
    console.error('Error fetching farms:', error);
    throw error;
  }
  return data || [];
};

/**
 * Fetches a single farm by its ID.
 * Relies on RLS policies for security.
 */
export const getFarmById = async (id: string): Promise<Farm | null> => {
  const { data, error } = await supabase.from('farms').select('*').eq('id', id).single();
  if (error) {
    console.error(`Error fetching farm with id ${id}:`, error);
    throw error;
  }
  return data;
};

/**
 * Creates a new farm by calling the backend API.
 * @param farmData - The data for the new farm.
 */
export const createFarm = async (farmData: Omit<Farm, 'id' | 'created_at' | 'updated_at' | 'manager_id'>): Promise<Farm | null> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/farms/`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(farmData),
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error('Error creating farm:', errorData);
      throw new Error(errorData.detail || 'Failed to create farm');
    }
    return await response.json();
  } catch (error) {
    console.error('Network or other error creating farm:', error);
    throw error;
  }
};

/**
 * Updates an existing farm by calling the backend API.
 * @param id - The ID of the farm to update.
 * @param farmData - The partial data to update the farm with.
 */
export const updateFarm = async (id: string, farmData: Partial<Omit<Farm, 'id' | 'created_at' | 'manager_id'>>): Promise<Farm | null> => {
  try {
    const headers = await getAuthHeader();
    // The backend will handle setting updated_at.
    // If farmData includes updated_at, it might be ignored or could cause issues depending on backend logic.
    // It's safer to let the backend manage timestamps.
    const payload = { ...farmData };
    if ('updated_at' in payload) {
        delete (payload as Partial<Farm>).updated_at; // Ensure client doesn't send its own updated_at
    }

    const response = await fetch(`${API_BASE_URL}/api/v1/farms/${id}`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error(`Error updating farm with id ${id}:`, errorData);
      throw new Error(errorData.detail || `Failed to update farm ${id}`);
    }
    return await response.json();
  } catch (error) {
    console.error(`Network or other error updating farm with id ${id}:`, error);
    throw error;
  }
};

/**
 * Deletes a farm by its ID by calling the backend API.
 * @param id - The ID of the farm to delete.
 */
export const deleteFarm = async (id: string): Promise<void> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/farms/${id}`, {
      method: 'DELETE',
      headers: headers,
    });
    if (!response.ok) {
      // DELETE typically returns 204 No Content on success, or an error object on failure.
      if (response.status === 204) return; // Success
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error(`Error deleting farm with id ${id}:`, errorData);
      throw new Error(errorData.detail || `Failed to delete farm ${id}`);
    }
    // If response.ok is true and status is not 204, it's unusual for DELETE.
    // But if backend sends a body on successful DELETE, handle it:
    // return await response.json(); // Or just return if no body expected.
  } catch (error) {
    console.error(`Network or other error deleting farm with id ${id}:`, error);
    throw error;
  }
};

// --- Farm User Permission Management ---

/**
 * Fetches all user permissions for a specific farm.
 * @param farmId - The ID of the farm.
 */
export const getFarmUserPermissions = async (farmId: string): Promise<UserPermission[]> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/user-permissions/${farmId}`, {
      method: 'GET',
      headers: headers,
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error(`Error fetching permissions for farm ${farmId}:`, errorData);
      throw new Error(errorData.detail || `Failed to fetch permissions for farm ${farmId}`);
    }
    return await response.json();
  } catch (error) {
    console.error(`Network or other error fetching permissions for farm ${farmId}:`, error);
    throw error;
  }
};

/**
 * Adds a user permission to a farm.
 * @param permissionData - The data for the new permission.
 */
export const addUserPermissionToFarm = async (permissionData: UserPermissionCreatePayload): Promise<UserPermission | null> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/user-permissions/`, { // Endpoint takes farm_id in body
      method: 'POST',
      headers: headers,
      body: JSON.stringify(permissionData),
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error('Error adding user permission:', errorData);
      throw new Error(errorData.detail || 'Failed to add user permission');
    }
    return await response.json();
  } catch (error) {
    console.error('Network or other error adding user permission:', error);
    throw error;
  }
};

/**
 * Updates a user's permission on a farm.
 * @param farmId - The ID of the farm.
 * @param userId - The ID of the user whose permission is to be updated.
 * @param permissionUpdateData - The new permission level.
 */
export const updateFarmUserPermission = async (
  farmId: string, 
  userId: string, 
  permissionUpdateData: UserPermissionUpdatePayload
): Promise<UserPermission | null> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/user-permissions/${farmId}/user/${userId}`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(permissionUpdateData),
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error(`Error updating permission for user ${userId} on farm ${farmId}:`, errorData);
      throw new Error(errorData.detail || 'Failed to update user permission');
    }
    return await response.json();
  } catch (error) {
    console.error(`Network or other error updating permission for user ${userId} on farm ${farmId}:`, error);
    throw error;
  }
};

/**
 * Removes a user's permission from a farm.
 * @param farmId - The ID of the farm.
 * @param userId - The ID of the user whose permission is to be removed.
 */
export const removeUserPermissionFromFarm = async (farmId: string, userId: string): Promise<void> => {
  try {
    const headers = await getAuthHeader();
    const response = await fetch(`${API_BASE_URL}/api/v1/user-permissions/${farmId}/user/${userId}`, {
      method: 'DELETE',
      headers: headers,
    });
    if (!response.ok) {
      if (response.status === 204) return; // Success
      const errorData = await response.json().catch(() => ({ detail: response.statusText }));
      console.error(`Error removing permission for user ${userId} on farm ${farmId}:`, errorData);
      throw new Error(errorData.detail || 'Failed to remove user permission');
    }
  } catch (error) {
    console.error(`Network or other error removing permission for user ${userId} on farm ${farmId}:`, error);
    throw error;
  }
}; 