{
  "tasks": [
    {
      "id": 1,
      "title": "Codebase Analysis and Architecture Documentation",
      "description": "Analyze the existing codebase to understand system architecture, frontend, backend, and deployment methods. Generate a comprehensive architecture summary document.",
      "details": "1. Clone and set up the existing repository locally\n2. Review system architecture documentation\n3. Analyze frontend architecture (Next.js components, state management, routing)\n4. Examine backend architecture (FastAPI endpoints, Supabase integration)\n5. Document local deployment process using Docker Compose\n6. Document remote deployment process on Render\n7. Create a comprehensive architecture summary document with diagrams showing:\n   - System component interactions\n   - Data flow between frontend, backend, and database\n   - Authentication flow via Supabase\n   - Device integration architecture with Home Assistant\n8. Identify potential architectural challenges or bottlenecks",
      "testStrategy": "Validate understanding by successfully deploying the application locally and on the test environment. Verify access to all components (frontend, backend, database). Have the architecture document reviewed by the team to ensure accuracy.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Repository Setup and Initial Import",
          "description": "Set up the code repository, ensuring all files are organized and accessible for analysis. Import the codebase into the chosen documentation or analysis tool.",
          "dependencies": [],
          "details": "This includes cloning or uploading the codebase, verifying file structure, and preparing the environment for further review.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "High-Level Architecture Review",
          "description": "Analyze the overall architecture of the codebase to identify main modules, their purposes, and interactions.",
          "dependencies": [
            1
          ],
          "details": "Review directory structure, main components, and system boundaries. Document the architectural patterns and key design decisions.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Frontend Code Analysis",
          "description": "Examine the frontend layer, including frameworks, main components, and data flow.",
          "dependencies": [
            2
          ],
          "details": "Identify UI structure, state management, and integration points with backend services. Note any unique patterns or libraries used.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Backend Code Analysis",
          "description": "Analyze the backend layer, focusing on APIs, business logic, and data management.",
          "dependencies": [
            2
          ],
          "details": "Document main services, endpoints, database interactions, and authentication mechanisms.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Deployment Documentation (Local)",
          "description": "Document the process for setting up and running the codebase locally.",
          "dependencies": [
            3,
            4
          ],
          "details": "Include environment setup, dependencies, configuration, and local testing instructions.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Deployment Documentation (Remote/Production)",
          "description": "Document the process for deploying the codebase to remote or production environments.",
          "dependencies": [
            5
          ],
          "details": "Detail CI/CD pipelines, environment variables, hosting requirements, and monitoring setup.",
          "status": "done"
        },
        {
          "id": 7,
          "title": "Diagram Creation",
          "description": "Create visual diagrams to illustrate system architecture, data flow, and component interactions.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Produce architecture diagrams, sequence diagrams, and deployment diagrams as needed.",
          "status": "done"
        },
        {
          "id": 8,
          "title": "Identification and Documentation of Architectural Challenges",
          "description": "Identify and document any architectural challenges, technical debt, or potential risks discovered during analysis.",
          "dependencies": [
            2,
            3,
            4,
            7
          ],
          "details": "Summarize issues such as scalability bottlenecks, security concerns, or maintainability challenges, and suggest possible mitigations.",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Farm Layout Configuration UI",
      "description": "Develop UI forms to define the hierarchical farm structure (Farms → Rows → Racks → Shelves) and store this configuration in Supabase.",
      "details": "1. Create React components for farm layout configuration:\n   - FarmCreationForm\n   - RowManagementPanel\n   - RackConfigurationForm\n   - ShelfDetailForm\n2. Implement drag-and-drop interface for visual layout configuration\n3. Design database schema for farm hierarchy:\n   ```sql\n   CREATE TABLE farms (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     name TEXT NOT NULL,\n     location TEXT,\n     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   \n   CREATE TABLE rows (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     farm_id UUID REFERENCES farms(id) ON DELETE CASCADE,\n     name TEXT NOT NULL,\n     position INTEGER NOT NULL\n   );\n   \n   CREATE TABLE racks (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     row_id UUID REFERENCES rows(id) ON DELETE CASCADE,\n     name TEXT NOT NULL,\n     position INTEGER NOT NULL\n   );\n   \n   CREATE TABLE shelves (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     rack_id UUID REFERENCES racks(id) ON DELETE CASCADE,\n     name TEXT NOT NULL,\n     position INTEGER NOT NULL\n   );\n   ```\n4. Implement Supabase API service for CRUD operations on farm layout\n5. Add validation to prevent duplicate names and ensure proper hierarchy\n6. Create visual confirmation for successful configuration changes",
      "testStrategy": "Unit tests for form validation and component rendering. Integration tests for Supabase CRUD operations. E2E tests for complete farm configuration workflow. Verify data persistence by refreshing the application and confirming layout remains intact.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "in-progress",
      "subtasks": [
        {
          "id": 1,
          "title": "UI Component Design",
          "description": "Create the visual components needed for the drag-and-drop interface",
          "dependencies": [],
          "details": "Design draggable elements with clear visual hierarchy using size, color, contrast, and texture to make them stand out. Include grab handles to indicate draggability. Implement hover effects to emphasize interactive elements. Ensure components are accessible for keyboard users with proper focus states.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Drag-and-Drop Implementation",
          "description": "Develop the core drag-and-drop functionality with proper visual feedback",
          "dependencies": [
            1
          ],
          "details": "Implement drag-and-drop mechanics that resemble physical movements. Use appropriate cursors that change on hover. Add elevation with drop-shadows for lifted items. Create clear drop zones with visual indicators. Implement smart defaults for suggested placements and auto-saving functionality.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Database Schema Design",
          "description": "Design the database structure to support hierarchical data relationships",
          "dependencies": [],
          "details": "Create tables and relationships that can store the hierarchical structure of draggable elements. Include fields for position tracking, parent-child relationships, and metadata. Ensure the schema supports efficient querying and updates during drag-and-drop operations.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Supabase API Integration",
          "description": "Connect the frontend to Supabase backend services",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement API calls to Supabase for CRUD operations. Set up real-time listeners for collaborative editing. Create functions to translate between UI state and database schema. Implement optimistic updates for a responsive feel during drag operations.\n<info added on 2025-05-20T21:50:11.481Z>\n## Environment Configuration\n- Store sensitive credentials (SUPABASE_KEY) in .env.local file which is excluded from Git via .gitignore\n- Configure SUPABASE_URL as an environment variable\n- Production environments will use hosting provider's environment variable settings\n- Never commit secrets to the repository\n\n## Git Workflow\n- Main branch: Production-ready code\n- Develop/staging branch: Pre-production integration\n- Feature branches: Individual development work\n- Changes flow: feature → develop → main\n- CI/CD pipeline will inject the appropriate environment variables for each deployment environment\n\n## Supabase Implementation\n- Configure Supabase client to use environment variables for authentication and connection\n- Ensure local development and production environments maintain proper separation of concerns\n</info added on 2025-05-20T21:50:11.481Z>\n<info added on 2025-05-20T22:00:20.470Z>\n## Client Configuration Standardization\n\n### Frontend Configuration\n- Use `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` in `frontend/src/supabaseClient.ts`\n- These variables are prefixed with NEXT_PUBLIC to make them available in the browser context\n- The anon key has limited permissions appropriate for client-side operations\n\n### Backend Configuration\n- Currently using `SUPABASE_URL` and `SUPABASE_KEY` in `backend/supabase_client.py`\n- Rename `SUPABASE_KEY` to `SUPABASE_SERVICE_KEY` for clarity\n- The service key provides elevated permissions for server-side operations\n- This key must never be exposed to the client\n\n### Implementation Plan\n1. Update backend environment variable naming in documentation and code\n2. Ensure all environment files and deployment configurations reflect the standardized naming\n3. Implement CRUD service functions with appropriate key usage based on operation context\n4. Add validation to prevent accidental exposure of service key to client-side code\n</info added on 2025-05-20T22:00:20.470Z>\n<info added on 2025-05-20T22:02:47.889Z>\n## Architecture for Supabase Integration\n\n### Frontend-First Approach\n- Implement direct Supabase calls from frontend for operations governed by Row Level Security (RLS)\n- Use `supabaseClient.ts` with `NEXT_PUBLIC_SUPABASE_ANON_KEY` for authenticated user operations\n- Create `frontend/src/services/farmService.ts` as the primary interface for farm layout CRUD operations\n- Initial implementation will focus on frontend-only operations for Farms, Rows, Racks, and Shelves\n\n### Backend Support Layer\n- Reserve backend FastAPI endpoints (using `supabase_client.py` with `SUPABASE_SERVICE_KEY`) for:\n  - Operations requiring elevated privileges beyond RLS capabilities\n  - Complex business logic that shouldn't be exposed to client\n  - Batch operations that would be inefficient client-side\n  - Data transformations requiring server-side processing\n\n### Implementation Strategy\n1. Define RLS policies in Supabase to secure frontend-direct operations\n2. Create frontend service functions with optimistic updates for responsive UI\n3. Identify operations requiring backend privileges during implementation\n4. Develop corresponding FastAPI endpoints only as needed for privileged operations\n5. Maintain clear separation between frontend-direct and backend-proxied database interactions\n</info added on 2025-05-20T22:02:47.889Z>\n<info added on 2025-05-20T22:24:30.260Z>\n## Revised API Integration Strategy\n\n### Frontend-Backend Responsibility Split\n- **Read Operations:** Remain in frontend services with direct Supabase calls\n  - Implement in `frontend/src/services/farmService.ts`, `rowService.ts`, etc.\n  - Secured by Row Level Security (RLS) policies in Supabase\n  - Functions: `getFarms()`, `getFarmById(id)`, etc.\n\n### Backend-Mediated Operations\n- **Write Operations:** Move to FastAPI backend endpoints\n  - Create endpoints: `POST /api/v1/farms`, `PUT /api/v1/farms/{id}`, `DELETE /api/v1/farms/{id}`\n  - Frontend services will call these endpoints instead of Supabase directly\n  - Backend will handle:\n    - JWT verification and authorization\n    - Input validation and business logic\n    - Audit logging for all write operations\n    - Supabase interactions using service role key\n\n### Implementation Plan\n1. Define and implement strong RLS policies for read operations\n2. Modify existing frontend services to:\n   - Keep direct Supabase calls for reads\n   - Redirect write operations to FastAPI endpoints\n3. Create corresponding FastAPI endpoints for all write operations\n4. Apply this pattern consistently across all entity types (farms, rows, racks, shelves)\n5. Document the security model and responsibility boundaries\n\n### Next Steps\n- Confirm RLS strategy for frontend read operations\n- Update `farmService.ts` implementation\n- Design and document FastAPI endpoint specifications\n</info added on 2025-05-20T22:24:30.260Z>\n<info added on 2025-05-20T22:26:06.219Z>\n## Row Level Security (RLS) Strategy Analysis\n\n### Options Evaluated for `farms` Table\n1. **All Authenticated Users Access**\n   - Simple implementation but lacks granular control\n   - Not suitable for multi-tenant or team environments\n   - Cannot restrict sensitive farm data between organizations\n\n2. **Manager-Based Access (via `manager_id`)**\n   - Direct ownership model ties farms to specific managers\n   - Good security for single-owner scenarios\n   - Limited flexibility for collaborative team environments\n\n3. **Permissions Table Approach (`farm_user_permissions`)**\n   - Many-to-many relationship between users and farms\n   - Supports granular permission levels (view, edit, admin)\n   - Enables team collaboration with different access levels\n   - Most scalable for enterprise features and complex organizations\n\n4. **Hybrid/Role-Based Approach**\n   - Admins have global access to all farms\n   - Managers see only farms they manage\n   - Simpler initial implementation than full permissions table\n   - Can evolve toward Option 3 as application matures\n\n### Implementation Recommendation\nImplement Option 3 (permissions table) for long-term scalability and security, unless project constraints require a simpler starting point with Option 4. The permissions table approach provides the most flexibility for future feature development and enterprise-level access control.\n\n### Next Steps\n- Confirm client requirements for farm access patterns\n- Determine if team collaboration is a current or future requirement\n- Design schema for `farm_user_permissions` table if Option 3 is selected\n- Document and implement the chosen RLS policies in Supabase\n</info added on 2025-05-20T22:26:06.219Z>\n<info added on 2025-05-20T22:29:56.907Z>\n## RLS Strategy Implementation Plan\n\n### Phase 1: Database Schema & RLS for Permissions\n- Define `permission_level` enum values: 'view', 'edit', 'manage'\n- Create `farm_user_permissions` table with columns:\n  - `id` (primary key)\n  - `farm_id` (foreign key to farms table)\n  - `user_id` (foreign key to auth.users)\n  - `permission_level` (enum type)\n  - `created_at` (timestamp with default)\n  - `updated_at` (timestamp with default)\n- Implement RLS policies on `farms` table:\n  - Read access: User must have any permission level in farm_user_permissions\n  - Write access: User must have 'edit' or 'manage' permission level\n  - Delete access: User must have 'manage' permission level\n- Document schema and policies in `docs/database-schema.md`\n\n### Phase 2: Backend API Implementation\n- Create FastAPI endpoints for Farm CRUD operations:\n  - `POST /api/v1/farms` - Creates farm and adds 'manage' permission for creator\n  - `PUT /api/v1/farms/{id}` - Updates farm (requires 'edit'/'manage' permission)\n  - `DELETE /api/v1/farms/{id}` - Deletes farm (requires 'manage' permission)\n- Create permission management endpoints:\n  - `GET /api/v1/farms/{farm_id}/permissions` - List all permissions for a farm\n  - `POST /api/v1/farms/{farm_id}/permissions` - Add new permission\n  - `PUT /api/v1/farms/{farm_id}/permissions/{id}` - Update permission\n  - `DELETE /api/v1/farms/{farm_id}/permissions/{id}` - Remove permission\n- Implement JWT verification and authorization checks in all endpoints\n\n### Phase 3: Frontend Service Implementation\n- Update `frontend/src/services/farmService.ts`:\n  - Keep direct Supabase calls for read operations (`getFarms`, `getFarmById`)\n  - Implement API calls for write operations (`createFarm`, `updateFarm`, `deleteFarm`)\n  - Add permission management functions (`getFarmPermissions`, `addFarmPermission`, etc.)\n- Implement optimistic updates for responsive UI during write operations\n- Add error handling and retry logic for API calls\n\n### Phase 4: Extend to Child Entities\n- Apply similar RLS patterns to rows, racks, and shelves tables\n- Implement inheritance of permissions from parent farm\n- Create corresponding FastAPI endpoints for each entity type\n- Update frontend services for each entity type following the same pattern\n</info added on 2025-05-20T22:29:56.907Z>\n<info added on 2025-05-20T22:30:24.016Z>\n## Permission System Design\n\n### Permission Levels\n- `viewer`: Read-only access to farm layout and settings\n- `editor`: Can create/update/delete farm entities (layout, components, etc.) for assigned farms\n- `manager`: All editor capabilities plus ability to manage user permissions (viewer, editor) for that farm\n\n### Permission Hierarchy\n- Permissions follow a hierarchical structure: `manager` > `editor` > `viewer`\n- Higher permission levels inherit all capabilities of lower levels\n- Future extension planned for `operate` permission for operational tasks\n\n### Farm User Permissions Table Schema\n```sql\nCREATE TYPE permission_level AS ENUM ('viewer', 'editor', 'manager');\n\nCREATE TABLE farm_user_permissions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  farm_id UUID REFERENCES farms(id) ON DELETE CASCADE,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  permission_level permission_level NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),\n  UNIQUE(farm_id, user_id)\n);\n\n-- Index for performance\nCREATE INDEX farm_user_permissions_farm_id_idx ON farm_user_permissions(farm_id);\nCREATE INDEX farm_user_permissions_user_id_idx ON farm_user_permissions(user_id);\n```\n\n### RLS Policy for Farms Read Access\n```sql\n-- Enable RLS on farms table\nALTER TABLE farms ENABLE ROW LEVEL SECURITY;\n\n-- Create policy for read access\nCREATE POLICY farm_read_access ON farms\n  FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n    )\n  );\n```\n\n### Platform Administration\n- Platform Admin (Super Admin) role will be implemented separately from the per-farm permission system\n- Super Admins will have global access across all farms and users\n- This role will be managed through a different mechanism, likely at the application level\n</info added on 2025-05-20T22:30:24.016Z>\n<info added on 2025-05-20T22:31:04.132Z>\n## Farm User Permissions Schema and RLS Implementation\n\n### `farm_user_permissions` Table Schema\n```sql\nCREATE TABLE farm_user_permissions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  farm_id UUID REFERENCES farms(id) ON DELETE CASCADE,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  permission TEXT NOT NULL CHECK (permission IN ('viewer', 'editor', 'manager')),\n  created_at TIMESTAMPTZ DEFAULT now(),\n  updated_at TIMESTAMPTZ DEFAULT now(),\n  UNIQUE (farm_id, user_id)\n);\n\n-- Indexes for query performance\nCREATE INDEX idx_farm_user_permissions_farm_id ON farm_user_permissions(farm_id);\nCREATE INDEX idx_farm_user_permissions_user_id ON farm_user_permissions(user_id);\n```\n\n### Row Level Security Policies for `farms` Table\n\n```sql\n-- Enable RLS on farms table\nALTER TABLE farms ENABLE ROW LEVEL SECURITY;\n\n-- Read access policy (SELECT)\nCREATE POLICY farms_select_policy ON farms\n  FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n    )\n    -- Placeholder for platform admin check\n    OR is_platform_admin()\n  );\n\n-- Update access policy (UPDATE)\nCREATE POLICY farms_update_policy ON farms\n  FOR UPDATE\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n      AND farm_user_permissions.permission IN ('editor', 'manager')\n    )\n    OR is_platform_admin()\n  );\n\n-- Delete access policy (DELETE)\nCREATE POLICY farms_delete_policy ON farms\n  FOR DELETE\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n      AND farm_user_permissions.permission = 'manager'\n    )\n    OR is_platform_admin()\n  );\n```\n\n### Platform Admin Function\n```sql\n-- Function to check if user is platform admin\n-- Implementation details to be determined based on how platform admins are identified\nCREATE OR REPLACE FUNCTION is_platform_admin()\nRETURNS BOOLEAN AS $$\nBEGIN\n  -- Placeholder implementation\n  -- Options:\n  -- 1. Check against a platform_admins table\n  -- 2. Check user's custom claims in JWT\n  -- 3. Check membership in a specific Supabase auth group\n  RETURN FALSE;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\nNote: While FastAPI will handle most write operations using the service key (bypassing RLS), these RLS policies provide defense-in-depth security for direct database access. The `is_platform_admin()` function implementation needs to be finalized based on how platform administrators will be identified in the system.\n</info added on 2025-05-20T22:31:04.132Z>\n<info added on 2025-05-20T22:35:45.414Z>\n## Finalized Schema and RLS Implementation\n\n### Permission Level Enum\n```sql\n-- Create enum type for permission levels\nCREATE TYPE permission_level_enum AS ENUM ('viewer', 'editor', 'manager');\n```\n\n### Farm User Permissions Table\n```sql\nCREATE TABLE farm_user_permissions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  farm_id UUID REFERENCES farms(id) ON DELETE CASCADE,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  permission permission_level_enum NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT now(),\n  updated_at TIMESTAMPTZ DEFAULT now(),\n  UNIQUE (farm_id, user_id)\n);\n\n-- Indexes for query performance\nCREATE INDEX idx_farm_user_permissions_farm_id ON farm_user_permissions(farm_id);\nCREATE INDEX idx_farm_user_permissions_user_id ON farm_user_permissions(user_id);\n```\n\n### Row Level Security Policies for Farms Table\n```sql\n-- Enable RLS on farms table\nALTER TABLE farms ENABLE ROW LEVEL SECURITY;\n\n-- Read access policy (SELECT)\nCREATE POLICY farms_select_policy ON farms\n  FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n    )\n    -- Placeholder for platform admin check\n    OR is_platform_admin()\n  );\n\n-- Update access policy (UPDATE)\nCREATE POLICY farms_update_policy ON farms\n  FOR UPDATE\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n      AND farm_user_permissions.permission IN ('editor', 'manager')\n    )\n    OR is_platform_admin()\n  );\n\n-- Delete access policy (DELETE)\nCREATE POLICY farms_delete_policy ON farms\n  FOR DELETE\n  USING (\n    EXISTS (\n      SELECT 1 FROM farm_user_permissions\n      WHERE farm_user_permissions.farm_id = farms.id\n      AND farm_user_permissions.user_id = auth.uid()\n      AND farm_user_permissions.permission = 'manager'\n    )\n    OR is_platform_admin()\n  );\n```\n\n### Platform Admin Function (Placeholder)\n```sql\n-- Function to check if user is platform admin (placeholder implementation)\nCREATE OR REPLACE FUNCTION is_platform_admin()\nRETURNS BOOLEAN AS $$\nBEGIN\n  -- Implementation details deferred\n  -- Will be updated with actual implementation in future\n  RETURN FALSE;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\nNext steps:\n1. Update `docs/database-schema.md` with this finalized schema\n2. Implement these SQL definitions in Supabase migrations\n3. Test RLS policies with different user permission levels\n4. Proceed with frontend and backend service implementations\n</info added on 2025-05-20T22:35:45.414Z>\n<info added on 2025-05-20T22:36:44.752Z>\n## Phase 1 Completion: Database Schema & RLS Implementation\n\nThe `farm_user_permissions` schema and `farms` RLS policies have been fully documented in `docs/database-schema.md`. The implementation includes:\n\n- `permission_level_enum` type definition with 'viewer', 'editor', and 'manager' levels\n- Complete `farm_user_permissions` table schema with appropriate foreign keys and constraints\n- Performance-optimized indexes on `farm_id` and `user_id` columns\n- Comprehensive RLS policies for the `farms` table:\n  - SELECT policy allowing access to users with any permission level\n  - UPDATE policy restricted to users with 'editor' or 'manager' permissions\n  - DELETE policy limited to users with 'manager' permission only\n- Placeholder `is_platform_admin()` function for future platform-wide administrative access\n\n## Phase 2: Backend API Implementation\n\n### Farm CRUD Endpoints\n- Implement `POST /api/v1/farms` endpoint:\n  - Create new farm record in database\n  - Automatically create 'manager' permission for the authenticated user\n  - Return newly created farm with ID\n- Implement `PUT /api/v1/farms/{id}` endpoint:\n  - Verify user has 'editor' or 'manager' permission\n  - Update farm details\n  - Return updated farm object\n- Implement `DELETE /api/v1/farms/{id}` endpoint:\n  - Verify user has 'manager' permission\n  - Perform cascading delete (will remove associated permissions)\n  - Return success status\n\n### Permission Verification\n- Create reusable permission verification middleware\n- Implement JWT validation and user identification\n- Add permission level checking against `farm_user_permissions` table\n- Include bypass mechanism for platform administrators\n</info added on 2025-05-20T22:36:44.752Z>\n<info added on 2025-05-21T15:25:50.674Z>\n## Backend Folder Structure Analysis\n\n### Current Structure Assessment\nThe current backend structure lacks clear separation of concerns and doesn't follow FastAPI best practices, which could lead to maintenance challenges as the codebase grows.\n\n### Recommended Structure\n```\nbackend/\n├── app/\n│   ├── core/\n│   │   ├── config.py         # Environment variables, app settings\n│   │   ├── security.py       # Authentication, authorization\n│   │   └── logging.py        # Logging configuration\n│   ├── db/\n│   │   ├── supabase_client.py # Supabase connection and client\n│   │   └── session.py        # Database session management\n│   ├── models/\n│   │   ├── farm.py           # Pydantic models for farms\n│   │   ├── user.py           # User models\n│   │   └── permission.py     # Permission models\n│   ├── crud/\n│   │   ├── farm.py           # Farm database operations\n│   │   └── permission.py     # Permission operations\n│   ├── api/\n│   │   ├── deps.py           # Dependency injection\n│   │   ├── v1/\n│   │   │   ├── endpoints/\n│   │   │   │   ├── farms.py  # Farm endpoints\n│   │   │   │   └── permissions.py # Permission endpoints\n│   │   │   └── router.py     # API router\n│   ├── tests/\n│   │   ├── conftest.py       # Test configuration\n│   │   ├── test_farms.py     # Farm endpoint tests\n│   │   └── test_permissions.py # Permission tests\n│   └── main.py               # Application entry point\n├── requirements.txt\n└── .env.example\n```\n\n### Benefits of Recommended Structure\n- **Separation of Concerns**: Clear boundaries between different parts of the application\n- **Modularity**: Easy to extend with new features\n- **Testability**: Structured for comprehensive testing\n- **Maintainability**: Easier for new developers to understand the codebase\n- **Scalability**: Supports growth without major restructuring\n\n### Decision Point\nNeed to decide whether to:\n1. Refactor the backend structure now before implementing Farm CRUD endpoints\n2. Proceed with current structure and refactor later\n\nThe recommended approach is to refactor now to avoid technical debt, but this depends on current project timeline constraints.\n</info added on 2025-05-21T15:25:50.674Z>\n<info added on 2025-05-21T15:32:57.376Z>\n## Backend Refactoring Implementation\n\n### Folder Structure Refactoring\n- Created standardized FastAPI project structure with `app/` directory and logical submodules\n- Organized code into: `core`, `db`, `models`, `crud`, `api`, `tests`, and `utils` modules\n- Relocated existing files to appropriate locations in the new structure\n- Updated all import paths to maintain functionality after restructuring\n\n### Model Implementation\n- Created Pydantic models in `app/models/`:\n  - `Farm` model with validation for farm properties\n  - `UserPermission` model with permission level validation\n  - Request/response schemas for all API operations\n\n### CRUD Operations\n- Implemented database operations in `app/crud/`:\n  - `farm.py`: create, read, update, delete functions for farms\n  - `permission.py`: functions to manage user permissions\n  - All operations use Supabase client with appropriate authentication\n\n### API Endpoints\n- Created Farm CRUD endpoints in `app/api/v1/endpoints/farms.py`:\n  - POST /farms - Creates farm and adds 'manager' permission for creator\n  - GET /farms - Lists farms accessible to current user\n  - GET /farms/{id} - Retrieves specific farm details\n  - PUT /farms/{id} - Updates farm properties\n  - DELETE /farms/{id} - Removes farm and cascades to permissions\n\n### Authentication & Authorization\n- Implemented JWT validation middleware in `app/core/security.py`\n- Created permission verification functions for endpoint protection\n- Added user context dependency injection in `app/api/deps.py`\n\n### Configuration Management\n- Centralized environment variable handling in `app/core/config.py`\n- Standardized Supabase client initialization with proper error handling\n- Implemented consistent logging configuration\n</info added on 2025-05-21T15:32:57.376Z>\n<info added on 2025-05-21T15:34:43.148Z>\n## Backend Configuration Updates\n\n### Configuration Files Alignment\n- Updated Dockerfile to use the new `app/` directory structure as the working directory\n- Modified entry point to reference `app.main:app` instead of previous path\n- Adjusted pytest.ini configuration to target the new test directory structure\n- Updated README.md with correct folder structure and setup instructions\n\n### Verification Steps\n- Confirmed all imports in refactored code are working correctly\n- Validated that Docker build completes successfully with new structure\n- Verified test suite runs properly against the refactored codebase\n- Checked requirements.txt contains all necessary dependencies for the project\n\n### Next Steps\n- Complete implementation of Farm CRUD endpoints using the new structure\n- Add comprehensive test coverage for all endpoints\n- Implement permission management endpoints following the same pattern\n- Document API endpoints in OpenAPI specification\n</info added on 2025-05-21T15:34:43.148Z>\n<info added on 2025-05-21T15:44:40.641Z>\n## Import Error Resolution\n\n### Fixed Import Issues\n- Corrected import statements for `schemas` module by updating relative import paths\n- Removed unused SQLAlchemy imports that were causing errors\n- Replaced custom Supabase client implementation with official `supabase-py` package\n\n### Package Dependencies\n- Updated `requirements.txt` to include:\n  - `supabase-py==1.0.3` (official Python client for Supabase)\n  - `python-jose[cryptography]` for JWT handling\n  - `pydantic>=2.0.0` for data validation\n  - Pinned FastAPI version to ensure compatibility\n\n### Next Implementation Steps\n1. Implement permission management endpoints:\n   - `GET /api/v1/farms/{farm_id}/permissions` - List all permissions for a farm\n   - `POST /api/v1/farms/{farm_id}/permissions` - Add new permission\n   - `PUT /api/v1/farms/{farm_id}/permissions/{id}` - Update permission level\n   - `DELETE /api/v1/farms/{farm_id}/permissions/{id}` - Remove permission\n2. Create corresponding Pydantic models in `app/models/permission.py`\n3. Implement CRUD operations in `app/crud/permission.py`\n4. Add permission verification middleware to ensure only farm managers can modify permissions\n</info added on 2025-05-21T15:44:40.641Z>\n<info added on 2025-05-21T15:48:05.730Z>\n## Supabase Library Correction\n\n### Package Dependency Fix\n- Changed from `supabase-py==1.0.3` to `supabase` in `requirements.txt`\n- This addresses Docker build errors: \"No matching distribution found for supabase-py\"\n- The correct package follows official Supabase documentation recommendation\n\n### Import Statement Updates\n- Updated import statements in backend Python files:\n  - `app/crud/crud_farm.py`: Changed from `from supabase_py import ...` to `from supabase import ...`\n  - `app/crud/crud_user_permission.py`: Updated imports to match official package structure\n  - Other affected files updated to maintain consistency\n\n### Verification Process\n- Docker image rebuild required to confirm fix\n- Backend application startup should proceed without library-related errors\n- Once verified, implementation of permission endpoints will continue:\n  - `/api/v1/farms/{farm_id}/permissions` endpoints for CRUD operations\n  - Permission management functionality following the established pattern\n</info added on 2025-05-21T15:48:05.730Z>\n<info added on 2025-05-21T15:52:05.318Z>\n## Pydantic V2 Compatibility Updates\n\n### Model Configuration Updates\n- Renamed `orm_mode = True` to `from_attributes = True` in Pydantic model configurations\n- Updated `FarmInDBBase` and `UserPermissionInDBBase` models to use V2-compatible syntax\n- Resolved deprecation warnings in console output during application startup\n\n### Permission Endpoints Implementation\n- Created new file `app/api/v1/endpoints/farm_permissions.py` for permission management\n- Implemented the following endpoints:\n  - `GET /api/v1/farms/{farm_id}/permissions` - List all permissions for a farm\n  - `GET /api/v1/farms/{farm_id}/permissions/{permission_id}` - Get specific permission details\n  - `POST /api/v1/farms/{farm_id}/permissions` - Assign new permission to user\n  - `PUT /api/v1/farms/{farm_id}/permissions/{permission_id}` - Update permission level\n  - `DELETE /api/v1/farms/{farm_id}/permissions/{permission_id}` - Revoke permission\n\n### Authorization Middleware\n- Added permission verification middleware to ensure only farm managers can:\n  - View all permissions for a farm\n  - Assign new permissions\n  - Modify existing permissions\n  - Revoke permissions\n- Implemented `check_farm_manager_permission` dependency in `app/api/deps.py`\n- Applied this dependency to all permission management endpoints\n\n### Testing Confirmation\n- Backend application successfully starts without warnings\n- Endpoints accessible and responding with appropriate status codes\n- Authorization checks working as expected for different permission levels\n</info added on 2025-05-21T15:52:05.318Z>",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Validation Logic",
          "description": "Implement rules and constraints for valid drag-and-drop operations",
          "dependencies": [
            2,
            4
          ],
          "details": "Create validation rules to prevent invalid drag operations. Implement constraints based on business logic. Add error handling and user feedback for invalid operations. Ensure data integrity is maintained during all operations.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Visual Feedback Enhancement",
          "description": "Refine the visual cues and feedback during drag-and-drop interactions",
          "dependencies": [
            2,
            5
          ],
          "details": "Add animations for smooth transitions during drag operations. Implement visual indicators for valid and invalid drop targets. Create feedback for successful/unsuccessful operations. Ensure the interface remains decluttered and focused on primary functions.",
          "status": "done"
        },
        {
          "id": 7,
          "title": "Testing and Optimization",
          "description": "Thoroughly test all aspects of the drag-and-drop functionality",
          "dependencies": [
            4,
            5,
            6
          ],
          "details": "Perform unit tests for individual components. Conduct integration tests for the complete system. Test edge cases and error handling. Optimize performance for large datasets. Ensure cross-browser compatibility and responsive design for different screen sizes.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Refine UI",
          "description": "",
          "details": "",
          "status": "in-progress",
          "dependencies": [],
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "Home Assistant Integration",
      "description": "Implement WebSocket and REST API integration with Home Assistant to enable device control and sensor monitoring.",
      "details": "1. Create a Home Assistant client service in FastAPI:\n   ```python\n   class HomeAssistantClient:\n       def __init__(self, base_url, access_token):\n           self.base_url = base_url\n           self.headers = {\n               \"Authorization\": f\"Bearer {access_token}\",\n               \"Content-Type\": \"application/json\"\n           }\n           self.websocket = None\n       \n       async def connect_websocket(self):\n           # WebSocket connection logic\n           pass\n           \n       async def get_entities(self, entity_type=None):\n           # Fetch entities from Home Assistant\n           pass\n           \n       async def call_service(self, domain, service, entity_id, data=None):\n           # Control devices via service calls\n           pass\n   ```\n2. Implement WebSocket subscription to sensor and device states\n3. Create endpoints in FastAPI to proxy Home Assistant API:\n   - GET /api/ha/entities - List all entities\n   - GET /api/ha/entities/{entity_id} - Get entity details\n   - POST /api/ha/services/{domain}/{service} - Call a service\n4. Add authentication and connection management\n5. Implement error handling and reconnection logic\n6. Create a background task for maintaining WebSocket connection\n7. Add caching layer for entity states to reduce API calls",
      "testStrategy": "Unit tests with mocked Home Assistant responses. Integration tests with a test Home Assistant instance. Test WebSocket reconnection on connection loss. Verify entity state updates are received in real-time. Test service calls for device control.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Client Service Implementation",
          "description": "Create a client service layer that abstracts the communication with external systems",
          "dependencies": [],
          "details": "Implement a service class that handles both WebSocket and REST communication patterns. Include connection management, serialization/deserialization of payloads, and retry logic for failed connections.\n<info added on 2025-06-06T22:33:03.577Z>\nDatabase analysis confirms the schema is fully optimized for Home Assistant integration. Existing tables such as `device_assignments`, `sensor_readings`, `scheduled_actions`, and `automation_rules` already support HA entities, sensor data, device control, and automation logic. The farm hierarchy enables device assignment at any level. Enhancements include a migration adding `integrations` and `integration_sync_log` tables for tracking HA connection status, sync events, and performance, plus an `integration_id` field in `device_assignments` to link devices to their integration source. No further schema changes are needed; backend and frontend can use these tables directly for seamless Home Assistant integration.\n</info added on 2025-06-06T22:33:03.577Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "WebSocket Connection Management",
          "description": "Implement WebSocket connection handling for real-time data updates",
          "dependencies": [
            1
          ],
          "details": "Develop WebSocket client implementation with connection lifecycle management (connect, disconnect, reconnect), heartbeat mechanism, and incremental update processing to reduce bandwidth usage.",
          "status": "in-progress"
        },
        {
          "id": 3,
          "title": "REST API Integration",
          "description": "Develop REST endpoint integration for non-real-time operations",
          "dependencies": [
            1
          ],
          "details": "Create REST client with appropriate request/response handling, implement API versioning support, and develop serialization/deserialization for various data formats.\n<info added on 2025-06-06T22:39:57.141Z>\n✅ REST API Integration Complete! Successfully implemented all missing backend functionality for device assignments:\n\nBackend Endpoints Added:\n- POST /devices/{entity_id}/assign - Assign device to farm location (shelf/rack/row/farm level)\n- GET /devices/assignments - Get device assignments with filtering by farm location\n- DELETE /devices/{entity_id}/assignment - Remove device assignment\n- GET /farms/{farm_id}/assigned-devices - Get all devices assigned to a farm with current states\n\nInfrastructure Complete:\n- Database service with AsyncPG connection pooling\n- Database URL auto-generation from Supabase config\n- Pydantic models for device assignment requests\n- Full database integration with device_assignments table\n- Added asyncpg dependency to requirements.txt\n- Application lifecycle management for database connections\n\nFrontend Updates:\n- Updated assignments tab to show implementation status\n- Indicated backend endpoints are ready\n\nDatabase ready: The existing device_assignments table is perfectly designed for this use case with support for farm hierarchy (shelf_id, rack_id, row_id, farm_id) and proper constraints.\n\nReady for Assignment: A user can now technically assign devices via API, but frontend assignment UI still needs full implementation.\n\nCurrent Capability: Backend can now store and retrieve device assignments. Frontend can connect to HA and discover devices. Next step would be building the actual assignment interface in the frontend.\n</info added on 2025-06-06T22:39:57.141Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Authentication System",
          "description": "Implement secure authentication for both WebSocket and REST connections",
          "dependencies": [
            2,
            3
          ],
          "details": "Develop authentication mechanisms including token management, credential storage, refresh token handling, and session maintenance across both connection types.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Error Handling and Recovery",
          "description": "Create robust error handling and recovery mechanisms",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Implement comprehensive error handling including connection failures, authentication errors, data validation issues, and automatic recovery procedures with exponential backoff.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Background Processing System",
          "description": "Develop background task processing for asynchronous operations",
          "dependencies": [
            5
          ],
          "details": "Create a background job system to handle long-running tasks, implement queuing mechanisms, and develop retry policies for failed background operations.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Caching Implementation",
          "description": "Implement efficient caching for frequently accessed data",
          "dependencies": [
            3,
            5
          ],
          "details": "Develop a caching layer using Redis or in-memory storage, implement cache invalidation strategies, and create mechanisms for dynamically adjusting cache policies based on usage patterns.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Integration Testing",
          "description": "Create comprehensive test suite for the integration",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "details": "Develop integration tests covering all components, implement performance benchmarks to measure efficiency, create mocks for external dependencies, and establish continuous integration pipeline.",
          "status": "pending"
        },
        {
          "id": 9,
          "title": "Frontend Integrations UI",
          "description": "Create frontend components and pages for the Home Assistant integration feature",
          "details": "Implement a comprehensive integrations page where users can:\n1. Add/configure Home Assistant connection\n2. View discovered devices and their current states  \n3. Assign devices to farm rows, racks, and shelves\n4. Control devices manually (on/off switches)\n5. View real-time device status updates via WebSocket\n<info added on 2025-06-06T22:13:38.317Z>\nNow that the frontend implementation is complete, we need to develop comprehensive integration tests for the Home Assistant integration. Based on best practices for integration testing:\n\n1. Create unit tests that verify the integration's core functionality without interacting with integration details directly\n2. Implement snapshot testing for complex outputs like entity states, registry entries, and diagnostic dumps\n3. Use realistic test data that mimics actual Home Assistant device responses and states\n4. Focus on critical integration points including:\n   - Connection setup and authentication\n   - Device discovery and listing\n   - Real-time WebSocket subscriptions and updates\n   - Device assignment to farm locations\n   - Manual device control operations\n5. Ensure tests cover error handling, edge cases, and recovery scenarios\n6. Follow Home Assistant's integration quality scale guidelines for gold-tier integrations\n7. Document testing procedures and troubleshooting steps for future developers\n</info added on 2025-06-06T22:13:38.317Z>",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 3
        }
      ]
    },
    {
      "id": 4,
      "title": "Device Assignment UI",
      "description": "Create a UI for mapping Home Assistant entities (lights, solenoids, pumps, fans, sensors) to their physical locations in the farm layout.",
      "details": "1. Create database schema for device assignments:\n   ```sql\n   CREATE TABLE device_assignments (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     shelf_id UUID REFERENCES shelves(id) ON DELETE CASCADE,\n     entity_id TEXT NOT NULL,\n     entity_type TEXT NOT NULL,\n     friendly_name TEXT,\n     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   ```\n2. Develop UI components:\n   - EntityBrowser (displays available Home Assistant entities)\n   - EntityAssignmentForm (assigns entity to farm location)\n   - LocationEntityList (shows entities assigned to a location)\n3. Implement drag-and-drop interface for assigning entities to shelves\n4. Add entity filtering by type (sensor, switch, light, etc.)\n5. Create FastAPI endpoints for device assignment operations\n6. Add validation to prevent duplicate assignments\n7. Implement entity search functionality\n8. Add visual indicators for assigned vs. unassigned entities",
      "testStrategy": "Unit tests for UI components and validation logic. Integration tests for assignment operations with Supabase. E2E tests for the complete assignment workflow. Verify assignments persist after page refresh. Test error handling for invalid assignments.",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and Create Database Schema",
          "description": "Define and implement the backend schema to support entities, assignments, and relationships required for the UI and drag-and-drop logic.",
          "dependencies": [],
          "details": "Include tables/models for entities, assignments, and any metadata needed for filtering and validation.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop API Endpoints",
          "description": "Implement RESTful or GraphQL API endpoints to support CRUD operations for entities, assignments, and search/filtering.",
          "dependencies": [
            1
          ],
          "details": "Endpoints should allow fetching, creating, updating, and deleting entities and assignments, as well as supporting search and filter queries.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Core UI Components",
          "description": "Develop reusable UI components for displaying entities, assignment lists, and interactive elements.",
          "dependencies": [],
          "details": "Components include entity cards, assignment containers, filter controls, and search bars.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Drag-and-Drop Assignment Logic",
          "description": "Enable drag-and-drop functionality for assigning entities, ensuring real-time updates and visual feedback.",
          "dependencies": [
            2,
            3
          ],
          "details": "Integrate with backend APIs to persist assignments and update UI state accordingly.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Add Entity Filtering Functionality",
          "description": "Implement UI and backend logic to filter entities based on user-selected criteria.",
          "dependencies": [
            2,
            3
          ],
          "details": "Support filtering by attributes such as type, status, or custom tags.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Integrate Search Functionality",
          "description": "Develop search features to allow users to quickly find entities or assignments.",
          "dependencies": [
            2,
            3
          ],
          "details": "Include debounced search input, backend query support, and result highlighting.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Implement Validation Logic",
          "description": "Add validation rules for assignments and entity interactions, both on the frontend and backend.",
          "dependencies": [
            2,
            4
          ],
          "details": "Ensure only valid assignments can be made and provide user feedback for invalid actions.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Develop Visual Indicators and Feedback",
          "description": "Create visual cues for assignment status, validation errors, and drag-and-drop interactions.",
          "dependencies": [
            4,
            7
          ],
          "details": "Include color changes, icons, tooltips, and animations to enhance user experience.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 5,
      "title": "Grow Recipe Management System",
      "description": "Develop a system for defining and managing grow recipes including grow days, light duration, watering frequency, and other parameters.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "medium",
      "details": "1. Design database schema for grow recipes:\n   ```sql\n   CREATE TABLE species (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     name TEXT NOT NULL UNIQUE,\n     description TEXT\n   );\n   \n   CREATE TABLE grow_recipes (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     species_id UUID REFERENCES species(id),\n     name TEXT NOT NULL,\n     recipe_source TEXT,\n     seed_density_dry NUMERIC(6,2),\n     avg_tray_yield NUMERIC(6,2),\n     germination_days INTEGER,\n     light_days INTEGER,\n     total_grow_days INTEGER,\n     top_coat TEXT,\n     pythium_risk TEXT,\n     water_intake NUMERIC(6,2),\n     water_frequency TEXT,\n     lighting JSONB,\n     fridge_storage_temp NUMERIC(4,1),\n     difficulty TEXT,\n     custom_parameters JSONB,\n     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n     updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   ```\n2. Create UI components for recipe management:\n   - SpeciesForm\n   - RecipeEditor with fields for all grow parameters\n   - RecipeList\n   - RecipeDetailView\n   - GrowParametersPage for navigating and managing recipes\n3. Implement CRUD operations for recipes via FastAPI endpoints\n4. Add recipe versioning to track changes\n5. Create recipe duplication functionality\n6. Implement recipe parameter validation\n7. Add recipe search and filtering capabilities\n8. Implement functionality to select recipes when starting a new grow for a rack/shelf",
      "testStrategy": "Unit tests for recipe validation and component rendering. Integration tests for recipe CRUD operations. Test recipe versioning to ensure history is maintained. Verify custom parameters are properly stored and retrieved. Test recipe duplication functionality. Verify all grow parameters (species, seed density, germination days, etc.) are correctly stored, retrieved, and displayed. Test the selection of recipes when starting a new grow.",
      "subtasks": [
        {
          "id": 1,
          "title": "Schema Design for Recipe Management",
          "description": "Create a comprehensive data model that handles the complexity of recipe structures while reducing data duplication",
          "dependencies": [],
          "details": "Design database schema that includes tables for recipes, species, and all required grow parameters. Schema should include fields for: species, recipe_source, seed_density_dry, avg_tray_yield, germination_days, light_days, total_grow_days, top_coat, pythium_risk, water_intake, water_frequency, lighting, fridge_storage_temp, and difficulty. Consider hierarchical recipe structures, inheritance patterns, and version control requirements. Include metadata fields for tracking creation, modification, and approval workflows.\n<info added on 2025-05-24T20:52:29.184Z>\nDatabase schema analysis complete. Need to create a migration to extend the existing `grow_recipes` table in Supabase with the following additional fields:\n\n- recipe_source (Text): Track origin of recipe data\n- germination_days (Integer): Days required for germination phase\n- light_days (Integer): Days requiring light exposure\n- total_grow_days (Integer): May be calculated or separate from existing grow_days\n- top_coat (Text/Boolean): Whether top coating is used\n- pythium_risk (Text): Risk level for pythium infection\n- water_intake (Numeric): Total water consumption\n- water_frequency (Text): Descriptive water frequency pattern\n- lighting (JSONB): Complex lighting schedule parameters\n- fridge_storage_temp (Numeric): Optimal refrigeration temperature\n- difficulty (Text): Cultivation difficulty rating\n\nNote: Existing fields `sowing_rate` and `average_yield` appear to correspond to required `seed_density_dry` and `avg_tray_yield` fields. Verify if these need renaming for consistency or can remain as is with proper documentation.\n</info added on 2025-05-24T20:52:29.184Z>\n<info added on 2025-05-24T20:53:43.679Z>\nMigration file 20250524155256_add_grow_recipe_parameters.sql successfully implemented. The migration extends the grow_recipes table with all required parameters including recipe_source, germination_days, light_days, total_grow_days, top_coat, pythium_risk, water_intake, water_frequency, lighting (as JSONB), fridge_storage_temp, and difficulty. \n\nKey implementation features:\n- Added appropriate data types and CHECK constraints for enum-like fields\n- Created indexes for frequently queried fields (difficulty, pythium_risk, total_grow_days)\n- Implemented PostgreSQL trigger to auto-calculate total_grow_days from germination_days + light_days when not explicitly set\n- Added descriptive comments for each field\n- Maintained backward compatibility with existing data\n\nConfirmed that existing fields sowing_rate and average_yield correspond to the required seed_density_dry and avg_tray_yield fields respectively, so no renaming was necessary.\n</info added on 2025-05-24T20:53:43.679Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "UI Component Development",
          "description": "Develop user interface components for recipe creation, editing, and visualization",
          "dependencies": [
            1
          ],
          "details": "Create reusable UI components for all grow parameters including species selection, seed density input, germination and light days settings, top coat options, pythium risk assessment, water intake and frequency controls, lighting configuration, storage temperature, and difficulty rating. Design a comprehensive 'Grow Parameters' page that allows users to view, add, edit, and delete grow recipes. Implement drag-and-drop functionality for recipe steps and responsive design for various devices. Ensure UI elements exist for inputting and displaying all required parameters.\n<info added on 2025-05-24T23:28:56.977Z>\nImplementation of the Grow Parameters feature has been successfully completed with the following components:\n\n1. TypeScript Types (src/types/grow-recipes.ts):\n   - Comprehensive type definitions for GrowRecipe, Species, CreateGrowRecipeInput\n   - LightingSchedule interface for complex JSONB data\n   - Filter and pagination types\n\n2. Service Layer (src/services/growRecipeService.ts):\n   - API service functions for species and grow recipes\n   - CRUD operations with filtering and pagination support\n   - Additional features: recipe duplication and compatibility checks\n\n3. UI Components:\n   - Badge component (src/components/ui/badge.tsx)\n   - GrowRecipeCard (src/components/grow-recipes/GrowRecipeCard.tsx)\n   - DeleteConfirmationDialog (src/components/grow-recipes/DeleteConfirmationDialog.tsx)\n   - GrowRecipeForm (src/components/grow-recipes/GrowRecipeForm.tsx) with sections for:\n     - Basic Information (name, species, source)\n     - Growing Timeline (germination, light, total days)\n     - Cultivation Parameters (seeding, watering, difficulty, pythium risk)\n     - Environmental Ranges (temperature, humidity, pH, EC)\n\n4. Main Page (src/app/grow-parameters/page.tsx):\n   - Search and filtering functionality\n   - Responsive grid layout for recipe cards\n   - Integration with form dialogs\n\nKey features implemented include parameter input fields, search/filtering by species/difficulty/pythium risk, inline species creation, Zod schema validation, responsive Tailwind CSS design, error handling with toast notifications, and auto-calculation of total grow days.\n</info added on 2025-05-24T23:28:56.977Z>",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "CRUD API Implementation",
          "description": "Develop comprehensive API endpoints for recipe management operations",
          "dependencies": [
            1
          ],
          "details": "Implement RESTful API endpoints for creating, reading, updating, and deleting recipes and their components. Ensure endpoints can handle all grow parameters (species, recipe_source, seed_density_dry, avg_tray_yield, germination_days, light_days, total_grow_days, top_coat, pythium_risk, water_intake, water_frequency, lighting, fridge_storage_temp, and difficulty). Include endpoints for partial updates, bulk operations, and specialized recipe operations. Design API responses to include appropriate error handling and validation feedback.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Versioning System Implementation",
          "description": "Create a robust versioning system to track recipe changes over time",
          "dependencies": [
            1,
            3
          ],
          "details": "Implement version control for recipes that tracks all changes, allows comparison between versions, and supports rollback functionality. Design a branching model for recipe development workflows. Include audit trails that capture who made changes and when.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Recipe Duplication and Template System",
          "description": "Develop functionality for recipe duplication, templates, and inheritance",
          "dependencies": [
            3,
            4
          ],
          "details": "Create systems for duplicating recipes while maintaining references, developing recipe templates, and implementing inheritance patterns for recipe variations. Include functionality to track relationships between original recipes and derivatives. Design mechanisms to propagate changes from base recipes to derivatives when appropriate.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Validation Framework Development",
          "description": "Implement comprehensive validation for recipes and their components",
          "dependencies": [
            1,
            3
          ],
          "details": "Create validation rules for all grow parameters including species, seed density, germination days, light days, water intake, etc. Implement business logic validation for recipe feasibility, cost calculations, and regulatory compliance. Design a flexible validation framework that can be extended for different product types and growing processes.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Search and Filtering System",
          "description": "Develop advanced search and filtering capabilities for recipe management",
          "dependencies": [
            1,
            3
          ],
          "details": "Implement full-text search across recipe components, advanced filtering by species, difficulty, grow days, and other parameters. Create saved search functionality and personalized views. Design efficient indexing strategies for large recipe databases and implement faceted search capabilities.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Recipe Selection for Grow Operations",
          "description": "Implement functionality to select recipes when starting a new grow",
          "dependencies": [
            2,
            3
          ],
          "details": "Develop interface and backend functionality that allows users to select from saved grow recipes when starting a new grow for a rack/shelf. Create a seamless workflow that applies the selected recipe's parameters to the new grow operation. Include validation to ensure the selected recipe is compatible with the target growing environment.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Scheduling and Automation Engine",
      "description": "Implement a scheduling system to automate grow operations based on recipes, including light cycles, watering, and other operations.",
      "details": "1. Design database schema for schedules:\n   ```sql\n   CREATE TABLE schedules (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     shelf_id UUID REFERENCES shelves(id) ON DELETE CASCADE,\n     recipe_id UUID REFERENCES grow_recipes(id),\n     start_date TIMESTAMP WITH TIME ZONE NOT NULL,\n     end_date TIMESTAMP WITH TIME ZONE,\n     status TEXT NOT NULL DEFAULT 'active',\n     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   \n   CREATE TABLE scheduled_actions (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     schedule_id UUID REFERENCES schedules(id) ON DELETE CASCADE,\n     action_type TEXT NOT NULL,\n     entity_id TEXT NOT NULL,\n     parameters JSONB,\n     execution_time TIMESTAMP WITH TIME ZONE NOT NULL,\n     status TEXT NOT NULL DEFAULT 'pending'\n   );\n   ```\n2. Implement scheduler service in FastAPI:\n   ```python\n   class SchedulerService:\n       def __init__(self, db, ha_client):\n           self.db = db\n           self.ha_client = ha_client\n       \n       async def create_schedule(self, shelf_id, recipe_id, start_date):\n           # Create schedule and generate initial actions\n           pass\n           \n       async def generate_actions(self, schedule_id):\n           # Generate actions based on recipe parameters\n           pass\n           \n       async def execute_pending_actions(self):\n           # Find and execute pending actions\n           pass\n   ```\n3. Create background task for action execution\n4. Implement recipe locking logic for sequential watering\n5. Add manual override capabilities\n6. Create UI components for schedule management\n7. Implement conflict detection for overlapping schedules\n8. Add notification system for failed actions",
      "testStrategy": "Unit tests for scheduler logic and action generation. Integration tests with Home Assistant for action execution. Test scheduling conflicts and resolution. Verify actions are executed at the correct times. Test manual overrides and their effect on scheduled actions.",
      "priority": "high",
      "dependencies": [
        3,
        4,
        5
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Schedule Schema Design",
          "description": "Design the database schema to support scheduling, including entities for tasks, resources, time slots, and dependencies.",
          "dependencies": [],
          "details": "Define tables and relationships for schedules, recipes, locks, overrides, and conflicts. Ensure schema supports real-time updates and concurrency.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Scheduler Service Implementation",
          "description": "Develop the core scheduling service responsible for creating, updating, and managing schedules in real time.",
          "dependencies": [
            1
          ],
          "details": "Implement logic for task assignment, time slot allocation, and integration with the schedule schema. Ensure scalability and low-latency operation.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Background Task Setup",
          "description": "Set up background workers or services to handle scheduled tasks, periodic checks, and automated actions.",
          "dependencies": [
            2
          ],
          "details": "Configure background processing for executing scheduled jobs, monitoring task status, and handling retries or failures.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Recipe Locking Mechanism",
          "description": "Implement a locking mechanism to prevent concurrent modifications to the same recipe or schedule entry.",
          "dependencies": [
            1,
            2
          ],
          "details": "Design and enforce locks at the database or application level to ensure data consistency and prevent race conditions.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Manual Override Functionality",
          "description": "Enable authorized users to manually override scheduled tasks or resolve conflicts as needed.",
          "dependencies": [
            2,
            4
          ],
          "details": "Provide interfaces and logic for manual intervention, including audit trails and rollback capabilities.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "User Interface Development",
          "description": "Develop the UI for schedule visualization, task management, manual overrides, and conflict resolution.",
          "dependencies": [
            2,
            5
          ],
          "details": "Design and implement intuitive screens for users to view, edit, and interact with schedules and notifications.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Conflict Detection and Resolution",
          "description": "Implement logic to detect scheduling conflicts and provide automated or manual resolution options.",
          "dependencies": [
            2,
            4,
            5
          ],
          "details": "Develop algorithms to identify overlapping tasks, resource contention, and notify users or trigger resolution workflows.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Notification System Integration",
          "description": "Build and integrate a notification system to alert users about schedule changes, conflicts, and task statuses.",
          "dependencies": [
            3,
            6,
            7
          ],
          "details": "Support real-time and asynchronous notifications via email, SMS, or in-app alerts, configurable by user preferences.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "Real-Time Monitoring Dashboard",
      "description": "Develop a live dashboard showing environmental conditions and system status with real-time updates via WebSockets.",
      "details": "1. Create WebSocket endpoint in FastAPI for real-time updates:\n   ```python\n   @app.websocket(\"/ws/dashboard\")\n   async def dashboard_websocket(websocket: WebSocket):\n       await websocket.accept()\n       try:\n           while True:\n               # Send real-time updates\n               data = await get_dashboard_data()\n               await websocket.send_json(data)\n               await asyncio.sleep(1)\n       except WebSocketDisconnect:\n           pass\n   ```\n2. Implement React components for the dashboard:\n   - EnvironmentalConditionsPanel\n   - SystemStatusPanel\n   - AlertsPanel\n   - SensorReadingsChart\n3. Use React hooks for WebSocket connection management\n4. Create data aggregation service for dashboard metrics\n5. Implement filtering by farm, row, rack, or shelf\n6. Add threshold-based alerting for sensor values\n7. Create visual indicators for normal/warning/critical states\n8. Implement auto-refresh and manual refresh options",
      "testStrategy": "Unit tests for dashboard components and WebSocket connection handling. Integration tests for real-time data updates. Test alert generation for threshold violations. Verify dashboard updates when sensor values change. Test dashboard filtering and aggregation logic.",
      "priority": "medium",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Secure WebSocket Endpoint",
          "description": "Implement a secure WebSocket endpoint using wss:// protocol with proper authentication and connection handling",
          "dependencies": [],
          "details": "Set up a Regional endpoint type for the WebSocket API, implement SSL/TLS certification, and ensure the endpoint follows security best practices. Configure proper error handling for connection failures.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement WebSocket Connection Management",
          "description": "Develop connection management logic including heartbeats, timeouts, and reconnection strategies",
          "dependencies": [
            1
          ],
          "details": "Create keep-alive mechanisms with ping/heartbeat messages to detect connection drops, implement connection timeouts for inactive connections, and build automatic reconnection logic with graceful degradation under high load.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Design Dashboard UI Component Architecture",
          "description": "Create the component hierarchy and layout structure for the real-time dashboard",
          "dependencies": [],
          "details": "Design reusable UI components for data visualization, establish the dashboard layout with proper responsiveness, and create component interfaces that will connect with WebSocket data streams.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop Data Aggregation Service",
          "description": "Create a service to collect, process, and aggregate real-time data from various sources",
          "dependencies": [
            1
          ],
          "details": "Implement data collection mechanisms, create aggregation algorithms to process incoming data streams, and optimize for performance with high-volume data handling.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Build Data Filtering System",
          "description": "Implement client and server-side filtering capabilities for the dashboard data",
          "dependencies": [
            3,
            4
          ],
          "details": "Create filtering mechanisms that work both on the server and client side, develop filter persistence, and ensure filtering operations maintain dashboard performance.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Create Alerting System",
          "description": "Develop a real-time alerting system that monitors data streams for specific conditions",
          "dependencies": [
            2,
            4
          ],
          "details": "Implement threshold-based alerts, create notification delivery mechanisms, and develop alert management interfaces for configuration and history tracking.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Implement Visual Indicators for Connection Status",
          "description": "Add visual feedback elements showing WebSocket connection status and data freshness",
          "dependencies": [
            2,
            3
          ],
          "details": "Create UI indicators for connection status (connected, disconnected, reconnecting), implement data freshness timestamps, and develop visual cues for stale or outdated information.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Develop Dashboard Refresh Logic",
          "description": "Implement intelligent refresh mechanisms for dashboard components",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Create component-specific refresh strategies, implement partial UI updates to minimize rendering, and develop fallback mechanisms for when WebSocket connections fail.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "Historical Analytics and Reporting",
      "description": "Create a system for visualizing historical data, yield history, and performance metrics to help refine growing practices.",
      "details": "1. Design database schema for historical data:\n   ```sql\n   CREATE TABLE sensor_history (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     entity_id TEXT NOT NULL,\n     value NUMERIC NOT NULL,\n     timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   \n   CREATE TABLE harvests (\n     id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n     shelf_id UUID REFERENCES shelves(id),\n     schedule_id UUID REFERENCES schedules(id),\n     yield_amount NUMERIC NOT NULL,\n     harvest_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n     notes TEXT\n   );\n   ```\n2. Implement data retention policy and aggregation for sensor data\n3. Create FastAPI endpoints for historical data retrieval\n4. Develop UI components for analytics:\n   - TimeSeriesChart\n   - YieldComparisonChart\n   - PerformanceMetricsPanel\n   - ReportGenerator\n5. Implement date range filtering\n6. Add export functionality (CSV, PDF)\n7. Create scheduled report generation\n8. Implement performance metrics calculation (yield per shelf, resource efficiency)",
      "testStrategy": "Unit tests for chart components and data aggregation. Integration tests for historical data retrieval. Test data export functionality. Verify metrics calculations are accurate. Test report generation with various parameters.",
      "priority": "low",
      "dependencies": [
        6,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Analytics Data Schema",
          "description": "Create a comprehensive data schema that supports long-term retention and efficient querying for analytics purposes",
          "dependencies": [],
          "details": "Define tables, relationships, and indexes optimized for analytics queries. Consider data classification types and identify which data needs longer retention periods. Include metadata fields for tracking data lifecycle and compliance with retention policies.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Data Retention Policy",
          "description": "Develop a data retention strategy with appropriate timelines for different data types",
          "dependencies": [
            1
          ],
          "details": "Research applicable legal regulations and business requirements for data retention. Create automated processes for archiving and purging data based on retention rules. Implement storage tiering to optimize costs while maintaining compliance with retention requirements.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Data Aggregation Pipeline",
          "description": "Create ETL processes to aggregate raw data into analytics-ready formats",
          "dependencies": [
            1
          ],
          "details": "Design and implement data transformation logic to convert raw data into aggregated metrics. Include validation steps to ensure data integrity. Create both real-time and batch processing capabilities to handle different analytics use cases.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop Analytics API",
          "description": "Create RESTful API endpoints for retrieving analytics data",
          "dependencies": [
            1,
            3
          ],
          "details": "Design API endpoints that support filtering, pagination, and sorting. Implement caching strategies to improve performance. Include authentication and authorization mechanisms to ensure data security. Document the API thoroughly for frontend developers.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create Core Analytics UI Components",
          "description": "Develop reusable UI components for data visualization",
          "dependencies": [
            4
          ],
          "details": "Build charts, graphs, and dashboard widgets that can visualize different types of metrics. Ensure components are responsive and perform well with large datasets. Implement theming support and accessibility features.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Implement Advanced Filtering and Search",
          "description": "Create UI and backend functionality for complex data filtering",
          "dependencies": [
            4,
            5
          ],
          "details": "Design and implement a flexible filtering system that allows users to create complex queries. Include saved filters functionality. Optimize backend query performance for filtered results. Create an intuitive UI for building and managing filters.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Develop Export and Reporting Functionality",
          "description": "Create mechanisms for exporting analytics data in various formats",
          "dependencies": [
            4,
            6
          ],
          "details": "Implement export capabilities for CSV, PDF, and Excel formats. Create templates for standardized reports. Build a scheduling system for automated report generation and delivery. Include customization options for exported reports.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Implement Complex Metrics Calculation",
          "description": "Develop algorithms for calculating advanced business metrics",
          "dependencies": [
            3,
            4
          ],
          "details": "Design and implement calculation logic for complex business KPIs and metrics. Create a framework for defining custom metrics. Ensure calculations are accurate and performant even with large datasets. Include validation and testing mechanisms for metrics accuracy.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "Role-Based Access Control",
      "description": "Implement role-based access control using Supabase Auth to differentiate between Farm Managers, Operators, and Home Assistant Power Users.",
      "details": "1. Define user roles and permissions:\n   ```sql\n   CREATE TYPE user_role AS ENUM ('farm_manager', 'operator', 'ha_power_user');\n   \n   CREATE TABLE user_profiles (\n     id UUID PRIMARY KEY REFERENCES auth.users(id),\n     role user_role NOT NULL DEFAULT 'operator',\n     name TEXT,\n     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n   );\n   \n   CREATE POLICY \"Users can view their own profile\"\n     ON user_profiles FOR SELECT\n     USING (auth.uid() = id);\n   \n   CREATE POLICY \"Farm managers can view all profiles\"\n     ON user_profiles FOR SELECT\n     USING (EXISTS (\n       SELECT 1 FROM user_profiles\n       WHERE id = auth.uid() AND role = 'farm_manager'\n     ));\n   ```\n2. Implement authentication UI components:\n   - LoginForm\n   - RegistrationForm\n   - UserProfileForm\n   - RoleManagementPanel\n3. Create protected routes in Next.js based on user roles\n4. Implement API endpoint authorization in FastAPI\n5. Add user invitation system\n6. Create audit logging for sensitive operations\n7. Implement session management and timeout",
      "testStrategy": "Unit tests for authentication components and authorization logic. Integration tests with Supabase Auth. Test access control for different user roles. Verify protected routes are properly secured. Test user invitation and registration flow.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Define App Roles and Permission Schema",
          "description": "Map out application roles, resources, and actions to create a comprehensive RBAC schema",
          "dependencies": [],
          "details": "Analyze application needs, define role hierarchy, identify protected resources, and specify permitted actions for each role. Document the complete permission matrix that will serve as the foundation for the entire RBAC implementation.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Authentication UI Components",
          "description": "Create user interface elements for authentication flow",
          "dependencies": [],
          "details": "Design and implement login, registration, password reset, and multi-factor authentication screens. Ensure proper validation, error handling, and accessibility compliance across all authentication interfaces.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Set Up Protected Routes",
          "description": "Configure route protection based on user roles and permissions",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement middleware or guards that verify user authentication and authorization before allowing access to protected routes. Create redirect logic for unauthorized access attempts and handle role-based navigation restrictions.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop API Authorization Layer",
          "description": "Build backend authorization mechanisms to secure API endpoints",
          "dependencies": [
            1
          ],
          "details": "Create middleware to validate access tokens, extract role information, and enforce permission checks on API endpoints. Implement proper error responses for unauthorized requests and ensure consistent authorization across all API resources.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create User Invitation System",
          "description": "Build functionality for inviting users with predefined roles",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop email invitation workflow with secure token generation, role assignment during invitation, and account activation process. Include admin interfaces for managing invitations and tracking invitation status.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Implement Audit Logging",
          "description": "Set up comprehensive logging for all access control events",
          "dependencies": [
            3,
            4
          ],
          "details": "Create logging infrastructure to record authentication attempts, authorization decisions, role changes, and resource access. Design log storage, retention policies, and admin interfaces for reviewing security events.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Develop Session Management",
          "description": "Implement secure session handling with role-aware capabilities",
          "dependencies": [
            2,
            4
          ],
          "details": "Build session creation, validation, and expiration mechanisms. Implement token refresh logic, concurrent session handling, and forced logout capabilities. Ensure sessions maintain and respect role information throughout their lifecycle.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "Harvest Logging and Yield Tracking",
      "description": "Develop a mobile-friendly UI for operators to log harvests and track yields, with data synchronization to the main system.",
      "details": "1. Create UI components for harvest logging:\n   - HarvestEntryForm\n   - YieldTracker\n   - HarvestHistory\n   - BatchLabelGenerator\n2. Implement responsive design for mobile use\n3. Create FastAPI endpoints for harvest data:\n   ```python\n   @app.post(\"/api/harvests\")\n   async def create_harvest(harvest: HarvestCreate, user=Depends(get_current_user)):\n       # Validate and store harvest data\n       return await harvest_service.create_harvest(harvest, user.id)\n   \n   @app.get(\"/api/harvests\")\n   async def list_harvests(shelf_id: Optional[str] = None, user=Depends(get_current_user)):\n       # Retrieve harvest history with optional filtering\n       return await harvest_service.list_harvests(user.id, shelf_id)\n   ```\n4. Add offline support with local storage\n5. Implement data synchronization when connection is restored\n6. Create barcode/QR code scanning for shelf identification\n7. Add photo upload capability for harvest documentation\n8. Implement yield comparison against recipe expectations",
      "testStrategy": "Unit tests for harvest logging components and validation. Integration tests for harvest data storage and retrieval. Test offline functionality and data synchronization. Verify mobile responsiveness on various device sizes. Test barcode scanning and photo upload features.",
      "priority": "medium",
      "dependencies": [
        2,
        5,
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "UI Component Development",
          "description": "Design and implement mobile-friendly UI components.",
          "dependencies": [],
          "details": "Focus on simplicity, consistency, and readability.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Responsive Design Implementation",
          "description": "Ensure UI components adapt to different screen sizes and orientations.",
          "dependencies": [
            1
          ],
          "details": "Use flexible layouts and media queries.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "API Endpoints Development",
          "description": "Create API endpoints for data interaction and synchronization.",
          "dependencies": [],
          "details": "Implement RESTful APIs for data exchange.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Offline Support Implementation",
          "description": "Enable app functionality without internet connectivity.",
          "dependencies": [
            3
          ],
          "details": "Use local storage and caching mechanisms.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Data Synchronization Logic",
          "description": "Develop logic to sync data when internet is available.",
          "dependencies": [
            4
          ],
          "details": "Use background services or periodic syncing.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Barcode/QR Scanning Integration",
          "description": "Integrate barcode and QR code scanning functionality.",
          "dependencies": [
            1
          ],
          "details": "Use device camera and scanning libraries.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Photo Upload Feature",
          "description": "Implement photo upload functionality with image processing.",
          "dependencies": [
            1
          ],
          "details": "Use device camera and image compression techniques.",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Yield Comparison Logic Development",
          "description": "Create logic to compare yields based on user input and data.",
          "dependencies": [
            5
          ],
          "details": "Use algorithms for data analysis and visualization.",
          "status": "pending"
        }
      ]
    }
  ]
}